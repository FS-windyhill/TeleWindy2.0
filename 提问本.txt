这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面
2.点击联系人可以进入的聊天页面

聊天页面中，我加了一个长按编辑消息的按钮，由此也更改发给ai的上下文。我的消息是一个消息组，user/char发出由两个换行分割的若干句子，UI识别两个换行符，由此将其在界面上切分成多条消息，以达到发送多条消息的视觉效果。但是我编辑消息，只打算编辑整个消息组，不打算编辑被切分后的消息。
（ps：原先一个消息组在UI上是被切分成多条消息的比如/n/n这样/n/n就是好几条。它在页面上是单独的message-wrapper，但是现在我把它们打包成message-group，这样点击其中拆分后的一条，就可以识别并编辑整组完整消息了）


现在的问题：
1.一旦【用户新发消息】之后，哪怕长按用户发的消息，点击编辑，弹出来的都是char的消息。不管长按【用户】的还是【char】的，编辑的都是【char】的消息。但是，【退出界面重新进一次】聊天窗口后，窗口UI根据历史上下文重新渲染界面，又能够正常编辑每一条消息了。

2.老师，手机界面长按编辑的时候，会跳出来ios/安卓系统自带的那个【复制、剪切、分享】啥啥的菜单，能给它禁用掉嘛？我感觉很影响体验

你帮我排查下问题好嘛，以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改把，谢谢gemini




这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面，像微信一样，有好友头像、和消息预览
2.点击联系人可以进入的聊天页面

我加了一个长按编辑消息的按钮，由此也更改发给ai的上下文。我的消息是一个消息组，user/char发出由两个换行分割的若干句子，UI识别两个换行符，由此将其在界面上切分成多条消息，以达到发送多条消息的视觉效果。但是我编辑消息，只打算编辑整个消息组，不打算编辑被切分后的消息。
（ps：原先一个消息组在UI上是被切分成多条消息的比如/n/n这样/n/n就是好几条。它在页面上是单独的message-wrapper，但是现在我把它们打包成message-group，这样点击其中拆分后的一条，就可以识别并编辑整组完整消息了）


我想修改的地方：
1.为了做到时间感知，用户每次发送消息都会被程序加上一条时间戳（让AI知道时间的变化）。时间戳是直接加在上下文里的，上下文是存在本地存储indexeddb的。类似下面的：

{role: 'assistant', content: '太好啦！\n\n我最喜欢跟朋友一起玩了！\n\n我们去草地上打滚好不好？\n\n或者，或者我们可以去那边的小溪边，用石头打水漂！'}
{role: 'user', content: '[Dec.14 16:39] 好耶！走吧'}

大概是这样。
长按编辑用户消息的时候，会弹出有个文本textarea弹窗嘛。但是，因为弹窗内容估计读取的是上下文，所以，编辑的时候，也会有个[Dec.14 16:39] 在里面。
感觉这样不够智能，会让用户看到底层逻辑。
能不能在编辑的时候通过正则，还是啥方法把这个隐藏掉呀，但是上下文里仍然保留。
这个时间不需要改成当前，就保留上下文的原样就好。

2.如果我聊天时，char消息还没发来，我就退到联系人页面去了，那 联系人页面 的 消息预览 里显示的就是我自己发的最后一条消息嘛。但是这里也会显示时间戳。我想把它隐藏掉。反正面向用户的时候，除了【调试日志】里之外，不要在任何地方让用户感到这个时间戳的存在。

3.如果在 联系人页面 时，char消息发来了，能实时预览不？就像微信那样显示当前最后一条消息（被/n/n拆分过后的）的预览，然后旁边有个小红点，显示它发了几条（不是一个message group哈，是被/n/n拆分过后的条数）


你帮我改下代码好嘛，以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改吧，谢谢gemini

/*
 * =========================================
 * 树状代码目录 (TeleWindy 项目结构)
 * =========================================
 *
 * 1. CONFIG & STATE (配置与状态)
 *    ├─ CONFIG 对象
 *    │   └─ SYSTEM_PROMPT (系统提示词)
 *    └─ STATE 对象 (运行时状态)
 *
 * 1.5. DB UTILS (IndexedDB 简易封装)
 *    ├─ open()          → 打开数据库
 *    ├─ get(key)        → 读取数据
 *    ├─ set(key, value) → 写入数据
 *    ├─ remove(key)     → 删除数据
 *    ├─ clear()         → 清空数据库
 *    └─ exportAll()     → 导出所有数据（使用游标）
 *
 * 2. STORAGE SERVICE (本地持久化 - IndexedDB 版)
 *    ├─ load()                  → 初始化加载所有数据（设置、联系人、世界书 + 数据迁移）
 *    ├─ saveContacts()          → 保存联系人
 *    ├─ saveSettings()          → 保存设置
 *    ├─ saveWorldInfo()         → 保存世界书
 *    ├─ exportAllForBackup()    → 导出备份（含 Token 加密）
 *    └─ importFromBackup(data)  → 导入备份（含 Token 解密）
 *
 * 3. WORLD INFO ENGINE (世界书引擎)
 *    ├─ importFromST(jsonString, fileName) → 从 SillyTavern 格式导入世界书
 *    ├─ exportToST(book)                   → 导出为 SillyTavern 格式
 *    └─ scan(userText, history, currentContactId, currentContactName)
 *                                          → 扫描上下文并注入触发的内容
 *
 * 4. API SERVICE (LLM 通信)
 *    ├─ getProvider(url)      → 判断 API 提供商 (claude/gemini/openai)
 *    ├─ fetchModels(url, key) → 拉取可用模型列表
 *    ├─ estimateTokens(text)  → 估算 Token 数量（中英文分开计算）
 *    └─ chat(messages, settings) → 核心聊天请求（支持多种提供商 + 日志记录）
 *
 * 5. CLOUD SYNC (云同步 - Gist / 自定义服务器混合版)
 *    ├─ init()                  → 初始化 UI 与恢复状态
 *    ├─ toggleMode()            → 切换同步模式（Gist ↔ 自定义）
 *    ├─ showStatus(msg, isError)→ 显示同步状态
 *    ├─ getAuth()               → 安全获取 Token/密码
 *    ├─ _maskToken() / _unmaskToken() → Token 混淆/解混淆（防泄露）
 *    ├─ _preparePayload()       → 准备上传数据（含混淆）
 *    ├─ updateBackup()          → 主入口：根据模式上传
 *    ├─ findBackup()            → 自动查找 GitHub Gist 备份
 *    ├─ restoreBackup()         → 恢复备份
 *    ├─ _safeRestore(data)      → 安全恢复（防空间不足）
 *    ├─ _uploadToCustom()       → 自定义服务器上传
 *    ├─ _fetchFromCustom()      → 自定义服务器下载
 *    ├─ _uploadToGist()         → GitHub Gist 上传/更新
 *    └─ _fetchFromGist()        → GitHub Gist 下载
 *
 * 6. UI RENDERER (界面渲染与 DOM 操作)
 *    ├─ init()                       → 初始化外观与联系人列表
 *    ├─ applyAppearance()            → 应用主题与壁纸
 *    ├─ toggleTheme(newTheme)        → 切换日夜模式
 *    ├─ switchView(viewName)         → 切换列表 ↔ 聊天视图
 *    ├─ renderContacts()             → 渲染联系人侧边栏
 *    ├─ renderBookSelect()           → 渲染世界书下拉框
 *    ├─ updateCurrentBookSettingsUI()→ 更新当前书绑定角色 UI
 *    ├─ renderWorldInfoList()        → 渲染世界书条目列表
 *    ├─ initWorldInfoTab()           → 初始化世界书 Tab 页面
 *    ├─ renderChatHistory(contact)   → 渲染完整聊天记录
 *    ├─ createSingleBubble(...)      → 创建单个消息气泡
 *    ├─ appendMessageBubble(...)     → 追加消息气泡（支持分段）
 *    ├─ showEditModal(...)           → 显示消息编辑弹窗
 *    ├─ removeLatestAiBubbles()      → 删除最新 AI 消息组（用于重滚）
 *    ├─ scrollToBottom()             → 滚动到底部
 *    ├─ setLoading(isLoading)        → 设置“正在输入”状态
 *    ├─ updateRerollState(contact)   → 更新重滚按钮状态
 *    ├─ playWaterfall(fullText, ...) → 瀑布流逐段显示 AI 回复
 *    └─ renderPresetMenu()           → 渲染 API 预设下拉菜单
 *
 * 7. APP CONTROLLER (核心业务逻辑)
 *    ├─ init()                          → 应用启动入口（加载数据 → 初始化 UI → 绑定事件）
 *    ├─ enterChat(id)                   → 进入指定聊天
 *    ├─ handleSend(isReroll)            → 发送消息 / 重滚
 *    ├─ openSettings()                  → 打开主设置弹窗
 *    ├─ switchWorldInfoBook(bookId)     → 切换当前世界书
 *    ├─ bindCurrentBookToChar(charId)   → 绑定当前书到角色
 *    ├─ loadWorldInfoEntry(uid)         → 加载条目到编辑器
 *    ├─ saveWorldInfoEntry()            → 保存条目（含名称逻辑）
 *    ├─ deleteWorldInfoEntry()          → 删除条目
 *    ├─ clearWorldInfoEditor()          → 清空编辑器
 *    ├─ createNewBook()                 → 新建世界书
 *    ├─ renameCurrentBook()             → 重命名当前书
 *    ├─ deleteCurrentBook()             → 删除当前书
 *    ├─ exportCurrentBook()             → 导出当前书为 ST 格式
 *    ├─ handleImportWorldInfo(file)     → 导入 ST 世界书
 *    ├─ handleSavePreset()              → 保存 API 预设
 *    ├─ handleLoadPreset(index)         → 加载 API 预设
 *    ├─ handleDeletePreset()            → 删除 API 预设
 *    ├─ saveSettingsFromUI()            → 从设置界面保存
 *    ├─ handleMessageAction(action)     → 处理消息右键操作（编辑/删除/复制）
 *    ├─ showMessageContextMenu(...)     → 显示消息上下文菜单（含防误触）
 *    ├─ hideMessageContextMenu()        → 隐藏上下文菜单
 *    ├─ bindEvents()                    → 集中绑定所有 DOM 事件
 *    ├─ readFile(file)                  → 读取文件为 base64
 *    ├─ fetchModelsForUI()              → UI 中拉取模型列表
 *    ├─ bindImageUpload(...)            → 绑定图片上传逻辑
 *    ├─ openEditModal(id)               → 打开角色编辑弹窗
 *    └─ saveContactFromModal()          → 保存角色修改
 *
 * 8. UTILS & EXPORTS (工具函数与全局导出)
 *    ├─ formatTimestamp()               → 格式化时间戳
 *    ├─ window.exportData()             → 全局导出备份函数
 *    └─ window.importData(input)        → 全局导入备份函数
 *
 * 启动：window.onload = () => App.init();
 */







这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面
2.点击联系人可以进入的聊天页面

聊天页面中，每次加载全量历史记录比较卡顿，我可以每次加载15条吗，剩下的，拉到最上面，会有个“加载更多消息”按钮，点一次，加载15条。等到最后一次点的时候，可能不到15条，那就全部加载出来即可。

你帮我改下代码好嘛，以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改吧，谢谢gemini

html css js分开写可以吗，谢谢

/**
 * ================================================
 * TeleWindy 代码结构树状目录（2025-12-15）
 * ================================================
 *
 * 1. CONFIG & STATE (配置与状态)
 *    ├─ CONFIG 对象
 *    │   └─ SYSTEM_PROMPT
 *    └─ STATE 对象
 *
 * 1.5. DB UTILS (IndexedDB 简易封装)
 *    ├─ open()
 *    ├─ get(key)
 *    ├─ set(key, value)
 *    ├─ remove(key)
 *    ├─ clear()
 *    └─ exportAll()
 *
 * 2. STORAGE SERVICE (本地持久化 - IndexedDB 版)
 *    ├─ load()
 *    ├─ saveContacts()
 *    ├─ saveSettings()
 *    ├─ saveWorldInfo()
 *    ├─ exportAllForBackup()
 *    └─ importFromBackup(data)
 *
 * 3. WORLD INFO ENGINE (世界书引擎)
 *    ├─ importFromST(jsonString, fileName)
 *    ├─ exportToST(book)
 *    └─ scan(userText, history, currentContactId, currentContactName)
 *
 * 4. API SERVICE (LLM通信)
 *    ├─ getProvider(url)
 *    ├─ fetchModels(url, key)
 *    ├─ estimateTokens(text)
 *    └─ chat(messages, settings)
 *
 * 5. CLOUD SYNC (云同步 - Gist & 自定义服务器)
 *    ├─ init()
 *    ├─ toggleMode()
 *    ├─ showStatus(msg, isError)
 *    ├─ getAuth()
 *    ├─ _maskToken(token)
 *    ├─ _unmaskToken(maskedToken)
 *    ├─ _preparePayload()
 *    ├─ updateBackup()
 *    ├─ findBackup()
 *    ├─ restoreBackup()
 *    ├─ _safeRestore(data)
 *    ├─ _uploadToCustom()
 *    ├─ _fetchFromCustom(password)
 *    ├─ _uploadToGist()
 *    └─ _fetchFromGist(token)
 *
 * 6. UI RENDERER (DOM 操作与渲染)
 *    ├─ init()
 *    ├─ applyAppearance()
 *    ├─ toggleTheme(newTheme)
 *    ├─ switchView(viewName)
 *    ├─ renderContacts()
 *    ├─ renderBookSelect()
 *    ├─ updateCurrentBookSettingsUI()
 *    ├─ renderWorldInfoList()
 *    ├─ initWorldInfoTab()
 *    ├─ createSingleBubble(...)
 *    ├─ showEditModal(oldText, onConfirmCallback)
 *    ├─ removeLatestAiBubbles()
 *    ├─ renderChatHistory(contact)
 *    ├─ appendMessageBubble(...)
 *    ├─ scrollToBottom()
 *    ├─ setLoading(isLoading)
 *    ├─ updateRerollState(contact)
 *    ├─ playWaterfall(fullText, avatar, timestamp)
 *    └─ renderPresetMenu()
 *
 * 7. APP CONTROLLER (业务逻辑主控)
 *    ├─ init()
 *    ├─ enterChat(id)
 *    ├─ handleSend(isReroll)
 *    ├─ openSettings()
 *    ├─ switchWorldInfoBook(bookId)
 *    ├─ bindCurrentBookToChar(charId)
 *    ├─ loadWorldInfoEntry(uid)
 *    ├─ saveWorldInfoEntry()
 *    ├─ deleteWorldInfoEntry()
 *    ├─ clearWorldInfoEditor()
 *    ├─ createNewBook()
 *    ├─ renameCurrentBook()
 *    ├─ deleteCurrentBook()
 *    ├─ exportCurrentBook()
 *    ├─ handleImportWorldInfo(file)
 *    ├─ handleSavePreset()
 *    ├─ handleLoadPreset(index)
 *    ├─ handleDeletePreset()
 *    ├─ saveSettingsFromUI()
 *    ├─ handleMessageAction(action)
 *    ├─ hideMessageContextMenu()
 *    ├─ showMessageContextMenu(msgIndex, rect)
 *    ├─ bindEvents()
 *    ├─ readFile(file)
 *    ├─ fetchModelsForUI()
 *    ├─ bindImageUpload(...)
 *    ├─ openEditModal(id)
 *    └─ saveContactFromModal()
 *
 * 8. UTILS & EXPORTS (工具函数与全局导出)
 *    ├─ formatTimestamp()
 *    ├─ window.exportData()
 *    └─ window.importData(input)
 *
 * 启动入口：window.onload = () => App.init();
 * ================================================
 */




2.目前聊天界面好像是所有人公用的，比如我给喜羊羊发了消息，它还没回复完（并且窗口上方还在显示“用户正在输入”），我就点进懒洋洋的窗口，那么懒羊羊的窗口上方也会显示“用户正在输入”，而且喜羊羊新发的消息会追加到懒羊羊的窗口下，需要退出懒洋洋窗口重新进一遍，令UI重新渲染和懒羊羊的历史记录，界面才会变正常


长按复制的时候，因为复制估计读取的是上下文，所以，复制的时候，也会有个[Dec.14 16:39] 在里面。能不能当用户复制消息的时候，用正则把时间戳切掉呀？不过AI的消息没有时间戳，最好有/无时间戳都能兼容的那种。
我在【编辑】的相关代码里已经用正则去过时间戳了，但是【复制】相关代码还妹有。
// 3. 执行动作
if (action === 'edit') {
// ★ 修改点：智能分离时间戳
// 定义时间戳正则，跟你在 renderChatHistory 里用的一样
const timestampRegex = /^[[A-Z][a-z]{2}.\d{1,2}\s\d{2}:\d{2}]\s/;
2.第二个问题：我的istyping【对方正在输入...】有时候会在对方发消息过来之后还在显示，需要退出聊天界面，点开另一个人的窗口，让窗口重新渲染一下，变成【在线】，再回到那个窗口，才会正常显示【在线】。但这不是次次都发生，只是偶尔会发生
你帮我改下代码好嘛，以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改吧，谢谢gem










这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面
2.点击联系人可以进入的聊天页面

聊天页面中，消息逻辑是这样的：user/char发出由两个换行分割的若干句子，UI识别两个换行符，由此将其在界面上切分成多条消息，以达到发送多条消息的视觉效果。实际的上下文中，这些并不是多条消息，而只是带/N/N的单条消息。而UI中，我将其设为bubble->wrapper->message group的三级消息结构，一个group就是整个带/N/N的消息组，也就是一次发送的、在界面上被拆分为多条的所有消息。

我目前的UI加载逻辑是读取历史记录中的消息，并且用正则清洗掉其中的时间戳（但是保留实际历史上下文中的时间戳，只是在渲染的时候加以裁切，形成一种没有时间戳的视觉效果），以及简易的markdown格式美化（那些*和###）：在js中，将加*/#的文字设置为专门的一类，用CSS加以美化，比如实现加粗。

我目前的markdown识别还是很原始的，只是通过正则来识别，然后手动的把它作为CSS类进行加粗。但是我现在发现一个问题就是它没有办法显示表格。（不过呢气泡作为消息载体，气泡的宽度也是有限的好像，能让表格自适应bubble宽度吗）
不过现在先不想宽度那么多吧，先思考一下怎么才能让我的聊天记录窗口里面显示markdown格式的表格呢。

我之前的简易markdown长这样：

/**
 * 1. 简易 Markdown 解析器 (用于气泡渲染)
 * 注意：必须先进行 HTML 转义防止 XSS，然后再替换 Markdown 语法
 */
function parseCustomMarkdown(text) {
    if (!text) return '';

    // 1. XSS 防御：先把原有的 < > & 替换掉，防止用户输入恶意代码
    let html = text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");

    // 2. 处理引用 > (你的需求：直接删除 > 并视为双换行，以便后续切分)
    // 注意：这一步最好在切分气泡前做，但如果在气泡内渲染，我们可以把它变为空行或分割线
    // 如果你的切分逻辑是在渲染前做的，这里只处理残留的 visual 效果
    html = html.replace(/^>\s*/gm, '\n\n'); 

    // 3. 处理标题 ### (你的需求：加粗，字号不变)
    // 匹配 1-6 个 # 开头的行，将其内容包裹在 <b> 标签中
    html = html.replace(/^#+\s+(.*)$/gm, '<b>$1</b>');

    // 4. 处理加粗 ***bold*** 或 **bold**
    html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<b>$1</b>');
    html = html.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');

    // 5. 处理斜体 *italic*
    html = html.replace(/\*(.*?)\*/g, '<i>$1</i>');

    // 6. 处理圆点列表 * list (你的需求：- 不管，只处理 *)
    // 将行首的 "* " 替换为 "• " (实心圆点字符) 或者 HTML <ul> 结构
    // 为了保持气泡简单，直接用字符替换最稳妥
    html = html.replace(/^\*\s+/gm, '• ');

    // 7. 处理换行 (保留显示换行)
    html = html.replace(/\n/g, '<br>');

    return html;
}

/**
 * 2. 纯文本清洗器 (用于复制)
 * 你的需求：保留换行，去除所有 Markdown 符号 (*, #, >)
 */
function cleanMarkdownForCopy(text) {
    if (!text) return '';
    let clean = text;
    clean = clean.replace(/^>\s*/gm, '');  // 去引用
    clean = clean.replace(/^#+\s+/gm, ''); // 去标题
    
    // 👇 优化这一块：先去列表头的 "* "，再去剩下的 "*"
    clean = clean.replace(/^\*\s+/gm, ''); // 先删列表头的 * 和空格
    clean = clean.replace(/\*/g, '');      // 再删加粗/斜体的 *
    
    return clean;
}

我的代码目录：
中文树状代码目录：
- 1. CONFIG & STATE (配置与状态)
  - CONFIG: 定义配置常量，包括存储键、默认值和系统提示。
  - STATE: 定义运行时状态，包括联系人、世界信息书籍、当前联系人ID等。
- 1.5. DB UTILS (IndexedDB 简易封装)
  - DB.open(): 打开IndexedDB数据库，返回Promise。
  - DB.get(key): 从数据库获取指定键的值，返回Promise。
  - DB.set(key, value): 将值存入数据库的指定键，返回Promise。
  - DB.remove(key): 删除数据库中的指定键，返回Promise。
  - DB.clear(): 清空整个对象存储，返回Promise。
  - DB.exportAll(): 使用游标导出数据库所有数据，返回Promise。
- 2. STORAGE SERVICE (本地持久化 - IndexedDB 版)
  - Storage.load(): 加载设置、联系人和世界信息，支持从LocalStorage迁移数据。
  - Storage.saveContacts(): 保存联系人数据到IndexedDB。
  - Storage.saveSettings(): 保存设置数据到IndexedDB。
  - Storage.saveWorldInfo(): 保存世界信息书籍到IndexedDB。
  - Storage.exportAllForBackup(): 导出所有数据用于备份，加密Token。
  - Storage.importFromBackup(data): 从备份数据导入，解密Token并写入数据库。
- 3. WORLD INFO ENGINE (已修正)
  - WorldInfoEngine.importFromST(jsonString, fileName): 从SillyTavern格式导入世界信息条目，创建新书。
  - WorldInfoEngine.exportToST(book): 将世界书导出为SillyTavern格式的JSON。
  - WorldInfoEngine.scan(userText, history, currentContactId, currentContactName): 扫描上下文触发世界信息条目，返回触发的知识内容。
- 4. API SERVICE (LLM通信)
  - API.getProvider(url): 根据URL判断API提供者（如claude、gemini或openai）。
  - API.fetchModels(url, key): 从API获取模型列表。
  - API.estimateTokens(text): 估算文本的Token数量，区分CJK和其它字符。
  - API.chat(messages, settings): 发送聊天消息到API，支持不同提供者，记录日志并返回响应。
- 5. CLOUD SYNC (终极混合版 - 含安全防御)
  - CloudSync.init(): 初始化云同步UI，从本地存储恢复设置。
  - CloudSync.toggleMode(): 根据选择切换自定义URL或Gist模式，更新UI。
  - CloudSync.showStatus(msg, isError): 在UI显示状态消息，带颜色区分。
  - CloudSync.getAuth(): 获取认证Token或密码，支持加密兼容。
  - CloudSync._maskToken(token): 混淆Token以防扫描。
  - CloudSync._unmaskToken(maskedToken): 解混淆Token。
  - CloudSync._preparePayload(): 准备上传备份数据，混淆Token。
  - CloudSync.updateBackup(): 根据模式上传备份到自定义服务器或Gist。
  - CloudSync.findBackup(): 在GitHub搜索TeleWindy备份Gist并填充ID。
  - CloudSync.restoreBackup(): 从云端恢复备份，确认覆盖。
  - CloudSync._safeRestore(data): 安全恢复数据，解混淆Token并处理空间问题。
  - CloudSync._uploadToCustom(): 上传备份到自定义服务器。
  - CloudSync._fetchFromCustom(password): 从自定义服务器获取备份。
  - CloudSync._uploadToGist(): 上传备份到GitHub Gist，支持创建或更新。
  - CloudSync._fetchFromGist(token): 从GitHub Gist获取备份，支持截断处理。
- 6. UI RENDERER (DOM 操作)
  - UI.init(): 初始化UI，应用外观并渲染联系人。
  - UI.applyAppearance(): 应用壁纸和主题到body。
  - UI.toggleTheme(newTheme): 切换主题并保存。
  - UI.switchView(viewName): 切换联系人列表或聊天视图。
  - UI.renderContacts(): 渲染联系人列表，包括头像、预览和红点。
  - UI.renderBookSelect(): 渲染世界书选择下拉框。
  - UI.updateCurrentBookSettingsUI(): 更新当前书的角色绑定UI。
  - UI.renderWorldInfoList(): 渲染世界信息条目列表，带高亮。
  - UI.initWorldInfoTab(): 初始化世界信息Tab，包括角色选择和渲染。
  - UI.showEditModal(oldText, onConfirmCallback): 显示消息编辑模态框。
  - UI.removeLatestAiBubbles(): 移除聊天中最新AI消息组。
  - UI.renderChatHistory(contact, isLoadMore): 渲染聊天历史，支持加载更多。
  - UI.createSingleBubble(text, sender, aiAvatarUrl, timestampRaw, historyIndex, shouldAnimate): 创建单个消息气泡，支持Markdown和动画。
  - UI.appendMessageBubble(text, sender, aiAvatarUrl, timestampRaw, historyIndex): 追加消息气泡到组。
  - UI.scrollToBottom(): 滚动聊天到底部。
  - UI.setLoading(isLoading, contactId): 设置加载状态，显示“正在输入”或“在线”。
  - UI.updateRerollState(contact): 更新reroll按钮状态。
  - UI.playWaterfall(fullText, avatar, timestamp): 逐段追加AI消息，模拟瀑布动画。
  - UI.initStatusBar(): 初始化顶栏状态栏，包括时间和电量。
  - UI.renderPresetMenu(): 渲染API预设菜单，包括保存、加载和删除。
- 7. APP CONTROLLER (业务逻辑)
  - App.init(): 初始化应用，加载存储并绑定事件。
  - App.enterChat(id): 进入指定联系人聊天，渲染历史并更新状态。
  - App.handleSend(isReroll): 处理消息发送或reroll，包括API调用和UI更新。
  - App.openSettings(): 打开设置模态，填充值并初始化Tab。
  - App.switchWorldInfoBook(bookId): 切换当前世界书并刷新UI。
  - App.bindCurrentBookToChar(charId): 绑定当前书到角色并保存。
  - App.loadWorldInfoEntry(uid): 加载世界信息条目到编辑器。
  - App.saveWorldInfoEntry(): 保存或新建世界信息条目。
  - App.deleteWorldInfoEntry(): 删除世界信息条目。
  - App.clearWorldInfoEditor(): 清空世界信息编辑器。
  - App.createNewBook(): 创建新世界书。
  - App.renameCurrentBook(): 重命名当前世界书。
  - App.deleteCurrentBook(): 删除当前世界书。
  - App.exportCurrentBook(): 导出当前世界书为JSON。
  - App.handleImportWorldInfo(file): 处理世界信息导入文件。
  - App.handleSavePreset(): 保存API预设。
  - App.handleLoadPreset(index): 加载API预设到UI。
  - App.handleDeletePreset(): 删除API预设。
  - App.saveSettingsFromUI(): 从设置UI保存配置。
  - App.handleMessageAction(action): 处理消息动作如编辑、删除、复制。
  - App.hideMessageContextMenu(): 隐藏消息上下文菜单。
  - App.showMessageContextMenu(msgIndex, rect): 显示消息上下文菜单，防误触。
  - App.bindEvents(): 绑定所有事件监听器。
  - App.readFile(file): 读取文件为Base64。
  - App.fetchModelsForUI(): 从API获取模型并更新UI。
  - App.bindImageUpload(inputId, imgId, inputUrlId, callback): 绑定图片上传事件。
  - App.openEditModal(id): 打开角色编辑模态，填充值。
  - App.saveContactFromModal(): 从模态保存角色数据。
- 8. UTILS & EXPORTS (工具与启动)
  - formatTimestamp(): 生成格式化的时间戳字符串。
  - window.exportData(): 导出所有数据为JSON文件。
  - window.importData(input): 从文件导入备份数据，支持空间检查。
  - parseCustomMarkdown(text): 解析自定义Markdown为HTML，支持加粗、斜体等。
  - cleanMarkdownForCopy(text): 清洗Markdown为纯文本，用于复制。
  - window.onload: 启动应用初始化。











老师，这是一个类似sillytavern的AI聊天前端，我写的。我为了让AI感知时间，在user发的每一条消息前面都加了一条时间戳。类似：

你好啊！吃了吗？→处理后：[Dec.29 20:07]你好啊！吃了吗？

之前他都可以正常工作，后来项目改来改去，今天突然发现这个功能不见了？我发送的消息没有被加上时间戳了？

我渲染聊天界面、复制消息、编辑消息、contact联系人界面预览消息的时候，为了美观，都是用正则把时间戳（在视觉上）切掉的。唯一不同的是，编辑消息的时候，我只会在编辑框里把时间戳去掉（为了让时间戳不让用户看见，不然很不优雅），编辑提交之后还会重新拼回去。但是现在说这些也没用了，因为时间戳甚至都没有被加进上下文里。是啥地方出问题了吗？逻辑太复杂了我都搞不懂是哪里出错了。除了我前面粘贴给你的具体代码，下面是我的目录，有哪些代码是可能的嫌疑段落吗？











老师，这是一个类似sillytavern的AI聊天前端，我写的。这个软件要连API嘛，我现在有拉取模型啥的功能了，但是我还想加一个测试API的功能。我另外一个项目写了测试API的功能，但是太久远了我已经忘了我咋写的了，懒得想了。。。。。所以麻烦你帮我把另外一个项目的代码整理进我这个AI聊天项目里吧。

html css啥的单独分开写，你随便写个最简单的，我自己插进我的项目里就OK
只是原来我那个项目，测试结果是直接显示为文字的，但是我现在想加个测试的按钮。
然后测试结果放在某一行，我到时候扔某个input外面。

比如【测试API】  测完会显示 已连接！或者 连接失败，代码400（反正就是它返回的错误内容） 这种


这是我另外一个项目的测试API
/* ==================== 测试默认 API ==================== */
async function testDefaultApi() {
  const statusEl = apiStatus;
  if (!statusEl) return;

  statusEl.textContent = '连接中…';
  statusEl.className = 'status-pending';

  try {
    const response = await fetch(DEFAULT_API.url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${DEFAULT_API.key}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: DEFAULT_API.model,
        messages: [{ role: "user", content: "ping" }],
        max_tokens: 1
      })
    });

    if (response.ok) {
      statusEl.innerHTML = '√ 已连接';
      statusEl.className = 'status-success';
      statusEl.title = '默认 API 连接成功';
    } else {
      throw new Error(`HTTP ${response.status}`);
    }
  } catch (err) {
    statusEl.innerHTML = '× 连接失败';
    statusEl.className = 'status-failure';
    console.error("默认 API 测试失败：", err);
  }
}


这是我现在这个项目的API功能。



// =========================================
// 4. API SERVICE (LLM通信)
// =========================================
const API = {
    getProvider(url) {
        if (url.includes('anthropic')) return 'claude';
        if (url.includes('googleapis')) return 'gemini';
        return 'openai'; 
    },

    async fetchModels(url, key) {
        const modelsUrl = url.replace(/\/chat\/completions$/, '/models');
        const res = await fetch(modelsUrl, {
            method: 'GET',
            headers: { 'Authorization': `Bearer ${key}` }
        });
        if (!res.ok) throw new Error(`Status: ${res.status}`);
        return await res.json();
    },

    // 在 API 类内部添加一个估算 Token 的辅助函数
// 1. 新增：放在 API 类里面的辅助函数，用来估算 Token
    estimateTokens(text) {
        if (!text) return 0;
        // 简单粗暴的估算公式：
        // 中文/日文/韩文 (CJK) 算 1.8 个 Token
        // 英文/数字/符号 算 0.35 个 Token (约3个字母=1Token)
        const cjkCount = (text.match(/[\u4e00-\u9fa5\u3040-\u30ff\uac00-\ud7af]/g) || []).length;
        const otherCount = text.length - cjkCount;
        return Math.ceil(cjkCount * 1.8 + otherCount * 0.35);
    },

    async chat(messages, settings) {
        const { API_URL, API_KEY, MODEL } = settings;
        const provider = this.getProvider(API_URL);
        
        let fetchUrl = API_URL;
        let options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        };

        const lastUserMsg = messages.filter(m => m.role === 'user').pop()?.content || '';
        const sysPrompts = messages.filter(m => m.role === 'system').map(m => m.content).join('\n\n');

        // 构建请求体
        if (provider === 'claude') {
            options.headers['x-api-key'] = API_KEY;
            options.headers['anthropic-version'] = '2023-06-01';
            options.body = JSON.stringify({
                model: MODEL,
                system: sysPrompts,
                messages: [{ role: "user", content: lastUserMsg }],
                max_tokens: 60000,
                temperature: 1.1
            });
        } else if (provider === 'gemini') {
            fetchUrl = API_URL.endsWith(':generateContent') ? API_URL : `${API_URL}/${MODEL}:generateContent?key=${API_KEY}`;
            options.body = JSON.stringify({
                contents: [{ role: 'user', parts: [{ text: lastUserMsg }] }],
                system_instruction: { parts: [{ text: sysPrompts }] },
                generationConfig: { temperature: 1.1, maxOutputTokens: 60000 }
            });
        } else {
            // OpenAI Standard (SiliconFlow, DeepSeek, etc.)
            options.headers['Authorization'] = `Bearer ${API_KEY}`;
            options.body = JSON.stringify({
                model: MODEL,
                messages: messages,
                temperature: 1.1,
                max_tokens: 60000
            });
        }

            
        // ==========================================
        // 1. 发送前日志记录 (修复版)
        // ==========================================
        try {
            let requestBodyObject = options.body;
            if (typeof options.body === 'string') {
                requestBodyObject = JSON.parse(options.body);
            }
            
            console.log(`[${provider}] Sending...`, requestBodyObject);

            // 直接存入全局变量
            window.LAST_API_LOG = {
                content: JSON.stringify(requestBodyObject, null, 2),
                tokens: 0, 
                isEstimated: true 
            };

        } catch (error) {
            console.error("【API日志记录失败】", error);
        }

        const response = await fetch(fetchUrl, options);
        if (!response.ok) {
            const errText = await response.text();
            throw new Error(`API Error ${response.status}: ${errText}`);
        }
        
        const data = await response.json();

        // ==========================================
        // 2. 发送后：拿到真实 Token (修复版)
        // ==========================================
        console.log(`[${provider}] Raw Response:`, data);

        if (data.usage && data.usage.prompt_tokens) {
            // 完美情况：API 返回了 token
            if (window.LAST_API_LOG) {
                window.LAST_API_LOG.tokens = data.usage.prompt_tokens;
                window.LAST_API_LOG.isEstimated = false;
            }
            console.log(`API返回真实Token消耗: ${data.usage.prompt_tokens}`);
        } else {
            // 保底情况：API 没返回，我们自己算
            // ★ 修改点：这里不要用 jsonStr，直接用 window.LAST_API_LOG.content
            if (window.LAST_API_LOG && window.LAST_API_LOG.content) {
                window.LAST_API_LOG.tokens = this.estimateTokens(window.LAST_API_LOG.content);
            }
        }
        

        
        if (provider === 'claude') return data.content[0].text.trim();
        if (provider === 'gemini') return data.candidates[0].content.parts[0].text.trim();
        return data.choices[0].message.content.trim();
    }
};

// =========================================


    async fetchModelsForUI() {
        const url = UI.els.settingUrl.value.trim();
        const key = UI.els.settingKey.value.trim();
        if(!url || !key) return alert('请先填写地址和密钥');
        const btn = UI.els.fetchBtn;
        btn.textContent = '获取中...';
        btn.disabled = true;
        try {
            const data = await API.fetchModels(url, key);
            const datalist = document.getElementById('model-options');
            if(datalist) datalist.innerHTML = '';
            if (data.data && Array.isArray(data.data)) {
                data.data.forEach(m => {
                    if(datalist) {
                        const opt = document.createElement('option');
                        opt.value = m.id;
                        datalist.appendChild(opt);
                    }
                });
                if (data.data.length > 0) {
                    UI.els.settingModel.value = data.data[0].id;
                }
                alert(`成功拉取 ${data.data.length} 个模型！`);
            } else {
                alert('连接成功，但对方没有返回有效的模型列表，请手动输入。');
            }
        } catch (e) {
            console.error(e);
            alert('拉取失败，请手动输入模型名。');
        } finally {
            btn.textContent = '拉取模型';
            btn.disabled = false;
        }
    },

    bindImageUpload(inputId, imgId, inputUrlId, callback) {
        const el = document.getElementById(inputId);
        if(!el) return;
        el.onchange = async (e) => {
            if(e.target.files[0]) {
                const base64 = await this.readFile(e.target.files[0]);
                document.getElementById(imgId).src = base64;
                if(inputUrlId) document.getElementById(inputUrlId).value = base64;
                if(callback) callback(base64);
            }
        };
    },





















这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面
2.点击联系人可以进入的聊天页面

聊天页面中，我加了一个长按编辑消息的按钮，由此也更改发给ai的上下文。我的消息是一个消息组，user/char发出由两个换行分割的若干句子，UI识别两个换行符，由此将其在界面上切分成多条消息，以达到发送多条消息的视觉效果。但是我编辑消息，只打算编辑整个消息组，不打算编辑被切分后的消息。
（ps：原先一个消息组在UI上是被切分成多条消息的比如/n/n这样/n/n就是好几条。它在页面上是单独的message-wrapper，但是现在我把它们打包成message-group，这样点击其中拆分后的一条，就可以识别并编辑整组完整消息了）


现在的问题：
1.我想加个像sillytavern那样的隐藏功能，就是在长按菜单里加。隐藏指的是：显示在屏幕上（但长相不一样：透明度更强一点，并取消原先气泡美化的blur，产生视觉差异，告诉用户该条消息已被隐藏），但是不发送给AI上下文。然后再次长按该条消息可以取消隐藏。

.message-wrapper.ai .message-bubble {
    background: var(--message-bg-ai);
    border: 1.2px solid var(--message-border-ai);
    padding: 8px 12px 10px 12px;
    border-top-left-radius: 3px;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

.message-wrapper.user .message-bubble {
    background: var(--message-bg-user);
    border: 1.2px solid var(--message-border-user);
    padding: 8px 12px 10px 12px;
    border-top-right-radius: 3px;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

    <!-- 1. 长按上下文菜单 (之前找不到的就是这个！) -->
    <div id="msg-context-menu" class="msg-context-menu" style="display: none;">
        <div class="menu-backdrop"></div>
        <div class="menu-panel">
            <button data-action="edit">编辑</button>
            <button data-action="copy">复制</button>
            <button data-action="delete">删除</button>
            <hr>
            <button data-action="cancel">取消</button>
        </div>
    </div>



以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改把，谢谢gemini

/*
// =========================================
// 中文的树状代码目录
// =========================================
// 注意：这是一个树状结构，展示代码的组织架构。每个章节对应代码中的主要部分，每个函数/对象后附带简要描述（这是干啥的）。
// 
// - 1. CONFIG & STATE (配置与状态)
//   - CONFIG: 常量配置对象，包含存储键、默认设置和系统提示等，用于全局配置。
//     - STORAGE_KEY: 'teleWindy_char_data_v1' // 联系人数据存储键
//     - SETTINGS_KEY: 'teleWindy_settings_v1' // 设置存储键
//     - WORLD_INFO_KEY: 'teleWindy_world_info_v2' // 世界信息存储键（升级到v2）
//     - CHAT_PAGE_SIZE: 15 // 每次加载的聊天条数
//     - GIST_ID_KEY: 'telewindy-gist-id' // Gist ID存储键
//     - DEFAULT: 默认配置对象，包括API_URL、MODEL等默认值
//     - SYSTEM_PROMPT: 系统提示字符串，用于指导AI行为
//   - STATE: 运行时状态对象，存储动态数据，如联系人列表、当前ID等。
//     - contacts: [] // 联系人数组
//     - worldInfoBooks: [] // 世界信息书籍数组
//     - currentContactId: null // 当前联系人ID
//     - currentBookId: null // 当前世界信息书籍ID
//     - settings: {} // 当前设置
//     - typingContactId: null // 正在输入的联系人ID
//     - visibleMsgCount: 15 // 当前显示的消息条数
// 
// - 1.5. DB UTILS (IndexedDB 简易封装)
//   - DB: IndexedDB操作对象，提供数据库交互方法。
//     - dbName: 'TeleWindyDB' // 数据库名称
//     - storeName: 'store' // 对象存储名称
//     - version: 1 // 数据库版本
//     - open(): 打开数据库，返回Promise // 异步打开IndexedDB数据库，处理升级。
//     - get(key): 获取指定键的值，返回Promise // 从数据库读取数据。
//     - set(key, value): 设置指定键的值，返回Promise // 向数据库写入数据。
//     - remove(key): 删除指定键，返回Promise // 从数据库删除数据。
//     - clear(): 清空存储，返回Promise // 清空整个对象存储。
//     - exportAll(): 导出所有数据，返回Promise // 使用游标遍历并导出所有键值对。
// 
// - 2. STORAGE SERVICE (本地持久化 - IndexedDB 版)
//   - Storage: 存储服务对象，处理数据加载和保存，包括迁移逻辑。
//     - load(): 加载所有数据，包括设置、联系人和世界信息 // 从IndexedDB或LocalStorage加载数据，进行迁移和默认处理。
//     - saveContacts(): 保存联系人数据 // 将STATE.contacts保存到IndexedDB。
//     - saveSettings(): 保存设置数据 // 将STATE.settings保存到IndexedDB。
//     - saveWorldInfo(): 保存世界信息数据 // 将STATE.worldInfoBooks保存到IndexedDB。
//     - exportAllForBackup(): 导出所有数据用于备份 // 从DB导出数据，加密Token，返回对象。
//     - importFromBackup(data): 导入备份数据 // 清空DB，解密Token，写入新数据。
// 
// - 3. WORLD INFO ENGINE (世界信息引擎，已修正)
//   - WorldInfoEngine: 世界信息处理对象，管理导入、导出和扫描。
//     - importFromST(jsonString, fileName): 从SillyTavern格式导入世界信息 // 解析JSON，创建新书籍条目，兼容旧格式。
//     - exportToST(book): 导出世界信息到SillyTavern格式 // 将书籍条目转换为JSON字符串。
//     - scan(userText, history, currentContactId, currentContactName): 扫描上下文触发世界信息 // 检查关键词或常量，返回触发的世界信息内容。
// 
// - 4. API SERVICE (LLM通信)
//   - API: API服务对象，处理模型获取和聊天请求。
//     - getProvider(url): 根据URL获取提供商类型 // 判断API是Claude、Gemini还是OpenAI。
//     - fetchModels(url, key): 获取模型列表 // 发送GET请求到/models端点，返回JSON。
//     - estimateTokens(text): 估算Token数量 // 根据字符类型粗略计算Token消耗。
//     - chat(messages, settings): 发送聊天请求 // 构建请求体，调用API，处理不同提供商，返回AI响应。
// 
// - 5. CLOUD SYNC (云同步，终极混合版 - 含安全防御)
//   - CloudSync: 云同步对象，处理Gist或自定义服务器备份。
//     - els: DOM元素对象 // 元素引用集合
//     - init(): 初始化同步界面 // 恢复保存的模式、URL等，调用toggleMode。
//     - toggleMode(): 切换同步模式 // 根据选择显示/隐藏URL或Gist ID输入。
//     - showStatus(msg, isError): 显示状态消息 // 更新状态文本和颜色。
//     - getAuth(): 获取认证Token或密码 // 从输入或设置读取Token，处理加密。
//     - _maskToken(token): 混淆Token // 反转并base64编码Token以防扫描。
//     - _unmaskToken(maskedToken): 解混淆Token // base64解码并反转Token。
//     - _preparePayload(): 准备上传负载 // 导出数据，混淆Token，添加元信息。
//     - updateBackup(): 更新备份 // 根据模式调用自定义或Gist上传。
//     - findBackup(): 查找Gist备份 // 请求Gist列表，匹配描述，更新ID。
//     - restoreBackup(): 恢复备份 // 确认后从云端拉取数据，调用_safeRestore。
//     - _safeRestore(data): 安全恢复数据 // 解混淆Token，清空旧数据，导入新数据，处理Quota错误。
//     - _uploadToCustom(): 上传到自定义服务器 // POST负载到自定义URL，使用密码认证。
//     - _fetchFromCustom(password): 从自定义服务器拉取 // GET请求，使用密码认证，返回JSON。
//     - _uploadToGist(): 上传到Gist // POST或PATCH到Gist API，创建或更新备份。
//     - _fetchFromGist(token): 从Gist拉取 // GET Gist内容，处理截断，返回JSON。
// 
// - 6. UI RENDERER (DOM 操作)
//   - UI: UI渲染对象，处理界面更新和事件。
//     - els: DOM元素对象 // 元素引用集合
//     - init(): 初始化UI // 应用外观，渲染联系人，初始化CloudSync。
//     - applyAppearance(): 应用外观设置 // 设置背景、主题。
//     - toggleTheme(newTheme): 切换主题 // 更新设置，应用外观。
//     - switchView(viewName): 切换视图 // 显示/隐藏联系人列表或聊天视图。
//     - renderContacts(): 渲染联系人列表 // 使用模板克隆填充联系人数据，包括预览和红点。
//     - renderBookSelect(): 渲染世界书选择下拉 // 填充书籍选项，更新UI。
//     - updateCurrentBookSettingsUI(): 更新当前书设置UI // 设置书籍绑定角色选择。
//     - renderWorldInfoList(): 渲染世界信息条目列表 // 填充条目，高亮当前编辑。
//     - initWorldInfoTab(): 初始化世界信息Tab // 填充角色选择，渲染书籍和列表。
//     - showEditModal(oldText, onConfirmCallback): 显示编辑弹窗 // 填充旧文本，绑定确认回调。
//     - removeLatestAiBubbles(): 移除最新AI气泡 // 删除聊天中最后一个AI消息组。
//     - renderChatHistory(contact, isLoadMore, keepScrollPosition): 渲染聊天历史 // 渲染消息，支持分页加载，控制滚动。
//     - appendMessageBubble(text, sender, aiAvatarUrl, timestampRaw, historyIndex): 添加消息气泡 // 创建并追加气泡到组，支持动画。
//     - appendSeparator(shouldAnimate): 添加分割线 // 创建并追加分割线，支持动画。
//     - scrollToBottom(): 滚动到底部 // 将聊天容器滚动到最底。
//     - setLoading(isLoading, contactId): 设置加载状态 // 更新“正在输入”状态，仅针对当前联系人。
//     - updateRerollState(contact): 更新重滚按钮状态 // 根据历史启用/禁用重滚按钮。
//     - playWaterfall(fullText, avatar, timestamp): 播放瀑布式动画 // 逐段渲染AI响应，支持分割线和动画。
//     - initStatusBar(): 初始化状态栏 // 更新时间、电量显示，绑定事件。
//     - renderPresetMenu(): 渲染API预设菜单 // 填充预设选项，绑定事件。
// 
// - 7. APP CONTROLLER (业务逻辑)
//   - App: 应用控制器对象，管理事件和逻辑。
//     - els: DOM元素引用 // 来自UI.els
//     - init(): 初始化应用 // 加载存储，初始化UI，绑定事件，渲染联系人。
//     - enterChat(id): 进入聊天 // 设置当前ID，切换视图，渲染历史，更新状态。
//     - handleSend(isReroll): 处理发送消息 // 构建消息，调用API，渲染响应，处理重滚。
//     - openSettings(): 打开设置弹窗 // 填充设置值，渲染预设，初始化世界信息Tab。
//     - switchWorldInfoBook(bookId): 切换世界书 // 更新当前ID，刷新UI。
//     - bindCurrentBookToChar(charId): 绑定书籍到角色 // 更新书籍characterId，保存。
//     - loadWorldInfoEntry(uid): 加载世界信息条目 // 填充编辑器输入框，刷新列表。
//     - saveWorldInfoEntry(): 保存世界信息条目 // 更新或新建条目，保存，刷新UI。
//     - deleteWorldInfoEntry(): 删除世界信息条目 // 移除条目，保存，清空编辑器，刷新列表。
//     - clearWorldInfoEditor(): 清空编辑器 // 重置输入框，刷新列表。
//     - createNewBook(): 创建新书 // 提示名称，添加新书，保存，刷新UI。
//     - renameCurrentBook(): 重命名当前书 // 提示新名，更新，保存，刷新选择。
//     - deleteCurrentBook(): 删除当前书 // 确认后移除书，切换到第一本，保存，刷新UI。
//     - exportCurrentBook(): 导出当前书 // 转换为JSON，下载文件。
//     - handleImportWorldInfo(file): 处理导入世界信息 // 读取文件，导入新书，保存，刷新UI。
//     - handleSavePreset(): 保存API预设 // 提示名称，添加预设，保存，刷新菜单。
//     - handleLoadPreset(index): 加载API预设 // 填充URL、Key、Model。
//     - handleDeletePreset(): 删除API预设 // 确认后移除预设，保存，刷新菜单。
//     - saveSettingsFromUI(): 从UI保存设置 // 更新设置，处理URL，保存，应用外观。
//     - handleMessageAction(action): 处理消息动作 // 根据动作编辑/删除/复制消息，保存，刷新历史。
//     - hideMessageContextMenu(): 隐藏上下文菜单 // 设置display none，重置索引。
//     - showMessageContextMenu(msgIndex, rect): 显示上下文菜单 // 设置索引，绑定事件，防误触锁定。
//     - bindEvents(): 绑定事件 // 绑定所有点击、输入、触摸事件。
//     - readFile(file): 读取文件为Base64 // 返回Promise，读取DataURL。
//     - fetchModelsForUI(): 从UI获取模型 // 调用API.fetchModels，填充选项。
//     - bindImageUpload(inputId, imgId, inputUrlId, callback): 绑定图片上传 // 监听change，读取Base64，更新预览，调用回调。
//     - openEditModal(id): 打开编辑弹窗 // 设置编辑ID，填充值，显示/隐藏按钮。
//     - saveContactFromModal(): 从弹窗保存联系人 // 更新或新建联系人，保存，刷新UI。
// 
// - 8. UTILS & EXPORTS (工具与启动)
//   - formatTimestamp(): 格式化时间戳 // 返回如"Dec.26 14:30"的字符串。
//   - window.exportData(): 全局导出函数 // 异步导出备份JSON文件。
//   - window.importData(input): 全局导入函数 // 读取文件，确认覆盖，导入数据，处理Quota错误。
//   - renderer: marked.Renderer对象 // 自定义Markdown渲染器，处理表格。
//   - parseCustomMarkdown(text): 解析自定义Markdown // 使用marked解析，DOMPurify净化，返回HTML。
//   - cleanMarkdownForCopy(text): 清洗Markdown为纯文本 // 去除符号，适合复制。
//   - window.onload: 启动应用 // 调用App.init()。
*/






这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面
2.点击联系人可以进入的聊天页面

联系人页面左上角有个main modal，其实就是设置，用来设置外观、API、内存等功能。而API中提供保存预设的服务，就是我可以输入好几个模型的URL和KEY，存在本地，我想用哪个模型聊天，就在下拉框里选谁。

联系人页面和聊天页面右上角都有一个人设编辑，我感觉这两个的html是同一个东西，只是【联系人】页面的【人设编辑】隐藏了一些功能，就当作一个创建人设的弹窗，只有上传头像、输入姓名、输入人设功能。但【聊天页面】的人设编辑则是所有功能都展现了，包括删除该联系人、删除聊天记录、查看聊天日志等。

如下：
    <!-- ======================= -->
    <!-- 弹窗：编辑/添加角色 -->
    <!-- ======================= -->
    <div id="modal-overlay" class="hidden">
        <div class="modal glass-panel">
            <h2 id="modal-title">编辑角色</h2>
            
            <div class="input-group">
                <label>名字</label>
                <input type="text" id="edit-name" placeholder="例如：AI助手">
            </div>

            <!-- 改成支持本地上传的头像区域 -->
            <div class="input-group avatar-upload-group">
                <label>角色头像</label>
                <div class="avatar-preview-wrapper">
                    <img id="edit-avatar-preview" class="avatar-preview" src="./char.jpg" alt="预览">
                    <input type="file" id="edit-avatar-file" accept="image/*" style="display:none;">
                    <button type="button" id="edit-avatar-upload-btn" class="small-btn">上传本地图片</button>
                </div>
                <input type="text" id="edit-avatar" placeholder="或输入 Emoji / 图片URL" value="⭐">
            </div>

            <!-- 新增：用户自己的头像上传（放在角色头像下面） -->
            <div class="input-group avatar-upload-group">
                <label>我的头像（用户头像）</label>
                <div class="avatar-preview-wrapper">
                    <img id="user-avatar-preview" class="avatar-preview" src="./user.jpg" alt="预览">
                    <input type="file" id="user-avatar-file" accept="image/*" style="display:none;">
                    <button type="button" id="user-avatar-upload-btn" class="small-btn">上传本地图片</button>
                </div>
            </div>


            <div class="input-group">
                <label>人设 (System Prompt)</label>
                <textarea id="edit-prompt" rows="5" placeholder="你是一个..."></textarea>
            </div>
            
            <div class="modal-buttons">
                <button id="modal-cancel">取消</button>
                <button id="modal-save" class="primary">保存</button>
            </div>


            <!-- 【新增区域】：上下文日志按钮 -->
            <div id="log-section" class="input-group log-section">
                <label>调试信息</label>
                <button id="btn-show-log" class="small-btn log-show-btn">
                    查看teleWindy的上轮发送
                </button>
            </div>

            
            <div class="modal-danger-zone">
                <button id="modal-clear-history" class="danger-btn outline">清空聊天记录</button>
                <button id="modal-delete" class="danger-btn">【危险操作】删除此角色</button>
            </div>

        </div>
    </div>



                <!-- ====================== 2. 模型 ====================== -->
                <div class="tab-pane" id="model">

                    <h3 class="section-title">API 与模型设置</h3>
                    <div class="main-options api-section">

                        <!-- ★★★ 新增：预设管理区域 ★★★ -->
                        <!-- 这里的 ID 必须和 JS 里对应，不要改 ID，class 可以随便改 -->
                        <div id="api-preset-container" class="preset-row">
                            <select id="preset-select" class="setting-input" style="flex:1;">
                                <option value="">-- 选择 API 预设 --</option>
                            </select>
                            <div class="preset-btn-group">
                                <button id="save-preset-btn" type="button" class="icon-btn">保存</button>
                                <button id="del-preset-btn" type="button" class="icon-btn danger">删除</button>
                            </div>
                        </div>
                        <!-- ★★★ 结束 ★★★ -->

                        <!-- API 地址 -->
                        <div class="main-option api-input-card">
                            <label class="api-label">API 地址，不加v1/chat/completions</label>
                            <input type="url" id="custom-api-url" class="setting-input" 
                                placeholder="例如: https://api.openai.com/v1">
                        </div>

                        <!-- API 密钥 -->
                        <div class="main-option api-input-card">
                            <label class="api-label">API 密钥</label>
                            <input type="password" id="custom-api-key" class="setting-input" 
                                placeholder="sk-XXXXXXXXXXXXXXXXXXXXXXXX" autocomplete="off">
                        </div>

                        <!-- 模型选择 -->
                        <div class="main-option model-card">
                            <label for="custom-model-select" class="api-label2">模型</label>


                            <!-- 模型设置区域 -->
                            <div class="model-setting-group">
                                
                                <!-- 1. 输入框 (去掉了右边的小图标) -->
                                <input type="text" id="custom-model-select" list="model-options" class="model-select" placeholder="手动输入或点击拉取...">
                                <datalist id="model-options"></datalist>

                                <!-- 2. 按钮组 (模仿 Gist 的排版，左右并排) -->
                                <div class="api-buttons-row">
                                    <button type="button" id="fetch-models-btn" class="api-btn primary">
                                        拉取模型
                                    </button>
                                    <button type="button" id="test-api-btn" class="api-btn">
                                        测试 API
                                    </button>
                                </div>

                                <!-- 3. 测试结果显示 (放在按钮下面) -->
                                <div id="test-api-status" class="api-status-text status-idle">- API测试准备就绪 -</div>

                            </div>


                        </div>
                    </div>
                </div>






现在的问题：
1.我想在【聊天页面】的联人设编辑中，加入“模型选择”功能，就是一个下拉框，显示预设里我已经保存过的那几个AI模型，第一个选项是默认，就是在main modal里已经选择的那个默认模型。其他选项是预设里保存过的其它模型。比如我全局用的是gemini，但是我觉得用glm-V4.6扮演喜羊羊最贴合人设，那我就可以喜羊羊的“模型选择”里选择我之前在设置里保存过的GLM V4.6了，以后我和喜羊羊聊天都会用这个GLM模型，直到我手动修改它。


以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改把，谢谢gemini



/*
// =========================================
// 中文的树状代码目录
// =========================================
// 注意：这是一个树状结构，展示代码的组织架构。每个章节对应代码中的主要部分，每个函数/对象后附带简要描述（这是干啥的）。
// 
// - 1. CONFIG & STATE (配置与状态)
//   - CONFIG: 常量配置对象，包含存储键、默认设置和系统提示等，用于全局配置。
//     - STORAGE_KEY: 'teleWindy_char_data_v1' // 联系人数据存储键
//     - SETTINGS_KEY: 'teleWindy_settings_v1' // 设置存储键
//     - WORLD_INFO_KEY: 'teleWindy_world_info_v2' // 世界信息存储键（升级到v2）
//     - CHAT_PAGE_SIZE: 15 // 每次加载的聊天条数
//     - GIST_ID_KEY: 'telewindy-gist-id' // Gist ID存储键
//     - DEFAULT: 默认配置对象，包括API_URL、MODEL等默认值
//     - SYSTEM_PROMPT: 系统提示字符串，用于指导AI行为
//   - STATE: 运行时状态对象，存储动态数据，如联系人列表、当前ID等。
//     - contacts: [] // 联系人数组
//     - worldInfoBooks: [] // 世界信息书籍数组
//     - currentContactId: null // 当前联系人ID
//     - currentBookId: null // 当前世界信息书籍ID
//     - settings: {} // 当前设置
//     - typingContactId: null // 正在输入的联系人ID
//     - visibleMsgCount: 15 // 当前显示的消息条数
// 
// - 1.5. DB UTILS (IndexedDB 简易封装)
//   - DB: IndexedDB操作对象，提供数据库交互方法。
//     - dbName: 'TeleWindyDB' // 数据库名称
//     - storeName: 'store' // 对象存储名称
//     - version: 1 // 数据库版本
//     - open(): 打开数据库，返回Promise // 异步打开IndexedDB数据库，处理升级。
//     - get(key): 获取指定键的值，返回Promise // 从数据库读取数据。
//     - set(key, value): 设置指定键的值，返回Promise // 向数据库写入数据。
//     - remove(key): 删除指定键，返回Promise // 从数据库删除数据。
//     - clear(): 清空存储，返回Promise // 清空整个对象存储。
//     - exportAll(): 导出所有数据，返回Promise // 使用游标遍历并导出所有键值对。
// 
// - 2. STORAGE SERVICE (本地持久化 - IndexedDB 版)
//   - Storage: 存储服务对象，处理数据加载和保存，包括迁移逻辑。
//     - load(): 加载所有数据，包括设置、联系人和世界信息 // 从IndexedDB或LocalStorage加载数据，进行迁移和默认处理。
//     - saveContacts(): 保存联系人数据 // 将STATE.contacts保存到IndexedDB。
//     - saveSettings(): 保存设置数据 // 将STATE.settings保存到IndexedDB。
//     - saveWorldInfo(): 保存世界信息数据 // 将STATE.worldInfoBooks保存到IndexedDB。
//     - exportAllForBackup(): 导出所有数据用于备份 // 从DB导出数据，加密Token，返回对象。
//     - importFromBackup(data): 导入备份数据 // 清空DB，解密Token，写入新数据。
// 
// - 3. WORLD INFO ENGINE (世界信息引擎，已修正)
//   - WorldInfoEngine: 世界信息处理对象，管理导入、导出和扫描。
//     - importFromST(jsonString, fileName): 从SillyTavern格式导入世界信息 // 解析JSON，创建新书籍条目，兼容旧格式。
//     - exportToST(book): 导出世界信息到SillyTavern格式 // 将书籍条目转换为JSON字符串。
//     - scan(userText, history, currentContactId, currentContactName): 扫描上下文触发世界信息 // 检查关键词或常量，返回触发的世界信息内容。
// 
// - 4. API SERVICE (LLM通信)
//   - API: API服务对象，处理模型获取和聊天请求。
//     - getProvider(url): 根据URL获取提供商类型 // 判断API是Claude、Gemini还是OpenAI。
//     - fetchModels(url, key): 获取模型列表 // 发送GET请求到/models端点，返回JSON。
//     - estimateTokens(text): 估算Token数量 // 根据字符类型粗略计算Token消耗。
//     - chat(messages, settings): 发送聊天请求 // 构建请求体，调用API，处理不同提供商，返回AI响应。
// 
// - 5. CLOUD SYNC (云同步，终极混合版 - 含安全防御)
//   - CloudSync: 云同步对象，处理Gist或自定义服务器备份。
//     - els: DOM元素对象 // 元素引用集合
//     - init(): 初始化同步界面 // 恢复保存的模式、URL等，调用toggleMode。
//     - toggleMode(): 切换同步模式 // 根据选择显示/隐藏URL或Gist ID输入。
//     - showStatus(msg, isError): 显示状态消息 // 更新状态文本和颜色。
//     - getAuth(): 获取认证Token或密码 // 从输入或设置读取Token，处理加密。
//     - _maskToken(token): 混淆Token // 反转并base64编码Token以防扫描。
//     - _unmaskToken(maskedToken): 解混淆Token // base64解码并反转Token。
//     - _preparePayload(): 准备上传负载 // 导出数据，混淆Token，添加元信息。
//     - updateBackup(): 更新备份 // 根据模式调用自定义或Gist上传。
//     - findBackup(): 查找Gist备份 // 请求Gist列表，匹配描述，更新ID。
//     - restoreBackup(): 恢复备份 // 确认后从云端拉取数据，调用_safeRestore。
//     - _safeRestore(data): 安全恢复数据 // 解混淆Token，清空旧数据，导入新数据，处理Quota错误。
//     - _uploadToCustom(): 上传到自定义服务器 // POST负载到自定义URL，使用密码认证。
//     - _fetchFromCustom(password): 从自定义服务器拉取 // GET请求，使用密码认证，返回JSON。
//     - _uploadToGist(): 上传到Gist // POST或PATCH到Gist API，创建或更新备份。
//     - _fetchFromGist(token): 从Gist拉取 // GET Gist内容，处理截断，返回JSON。
// 
// - 6. UI RENDERER (DOM 操作)
//   - UI: UI渲染对象，处理界面更新和事件。
//     - els: DOM元素对象 // 元素引用集合
//     - init(): 初始化UI // 应用外观，渲染联系人，初始化CloudSync。
//     - applyAppearance(): 应用外观设置 // 设置背景、主题。
//     - toggleTheme(newTheme): 切换主题 // 更新设置，应用外观。
//     - switchView(viewName): 切换视图 // 显示/隐藏联系人列表或聊天视图。
//     - renderContacts(): 渲染联系人列表 // 使用模板克隆填充联系人数据，包括预览和红点。
//     - renderBookSelect(): 渲染世界书选择下拉 // 填充书籍选项，更新UI。
//     - updateCurrentBookSettingsUI(): 更新当前书设置UI // 设置书籍绑定角色选择。
//     - renderWorldInfoList(): 渲染世界信息条目列表 // 填充条目，高亮当前编辑。
//     - initWorldInfoTab(): 初始化世界信息Tab // 填充角色选择，渲染书籍和列表。
//     - showEditModal(oldText, onConfirmCallback): 显示编辑弹窗 // 填充旧文本，绑定确认回调。
//     - removeLatestAiBubbles(): 移除最新AI气泡 // 删除聊天中最后一个AI消息组。
//     - renderChatHistory(contact, isLoadMore, keepScrollPosition): 渲染聊天历史 // 渲染消息，支持分页加载，控制滚动。
//     - appendMessageBubble(text, sender, aiAvatarUrl, timestampRaw, historyIndex): 添加消息气泡 // 创建并追加气泡到组，支持动画。
//     - appendSeparator(shouldAnimate): 添加分割线 // 创建并追加分割线，支持动画。
//     - scrollToBottom(): 滚动到底部 // 将聊天容器滚动到最底。
//     - setLoading(isLoading, contactId): 设置加载状态 // 更新“正在输入”状态，仅针对当前联系人。
//     - updateRerollState(contact): 更新重滚按钮状态 // 根据历史启用/禁用重滚按钮。
//     - playWaterfall(fullText, avatar, timestamp): 播放瀑布式动画 // 逐段渲染AI响应，支持分割线和动画。
//     - initStatusBar(): 初始化状态栏 // 更新时间、电量显示，绑定事件。
//     - renderPresetMenu(): 渲染API预设菜单 // 填充预设选项，绑定事件。
// 
// - 7. APP CONTROLLER (业务逻辑)
//   - App: 应用控制器对象，管理事件和逻辑。
//     - els: DOM元素引用 // 来自UI.els
//     - init(): 初始化应用 // 加载存储，初始化UI，绑定事件，渲染联系人。
//     - enterChat(id): 进入聊天 // 设置当前ID，切换视图，渲染历史，更新状态。
//     - handleSend(isReroll): 处理发送消息 // 构建消息，调用API，渲染响应，处理重滚。
//     - openSettings(): 打开设置弹窗 // 填充设置值，渲染预设，初始化世界信息Tab。
//     - switchWorldInfoBook(bookId): 切换世界书 // 更新当前ID，刷新UI。
//     - bindCurrentBookToChar(charId): 绑定书籍到角色 // 更新书籍characterId，保存。
//     - loadWorldInfoEntry(uid): 加载世界信息条目 // 填充编辑器输入框，刷新列表。
//     - saveWorldInfoEntry(): 保存世界信息条目 // 更新或新建条目，保存，刷新UI。
//     - deleteWorldInfoEntry(): 删除世界信息条目 // 移除条目，保存，清空编辑器，刷新列表。
//     - clearWorldInfoEditor(): 清空编辑器 // 重置输入框，刷新列表。
//     - createNewBook(): 创建新书 // 提示名称，添加新书，保存，刷新UI。
//     - renameCurrentBook(): 重命名当前书 // 提示新名，更新，保存，刷新选择。
//     - deleteCurrentBook(): 删除当前书 // 确认后移除书，切换到第一本，保存，刷新UI。
//     - exportCurrentBook(): 导出当前书 // 转换为JSON，下载文件。
//     - handleImportWorldInfo(file): 处理导入世界信息 // 读取文件，导入新书，保存，刷新UI。
//     - handleSavePreset(): 保存API预设 // 提示名称，添加预设，保存，刷新菜单。
//     - handleLoadPreset(index): 加载API预设 // 填充URL、Key、Model。
//     - handleDeletePreset(): 删除API预设 // 确认后移除预设，保存，刷新菜单。
//     - saveSettingsFromUI(): 从UI保存设置 // 更新设置，处理URL，保存，应用外观。
//     - handleMessageAction(action): 处理消息动作 // 根据动作编辑/删除/复制消息，保存，刷新历史。
//     - hideMessageContextMenu(): 隐藏上下文菜单 // 设置display none，重置索引。
//     - showMessageContextMenu(msgIndex, rect): 显示上下文菜单 // 设置索引，绑定事件，防误触锁定。
//     - bindEvents(): 绑定事件 // 绑定所有点击、输入、触摸事件。
//     - readFile(file): 读取文件为Base64 // 返回Promise，读取DataURL。
//     - fetchModelsForUI(): 从UI获取模型 // 调用API.fetchModels，填充选项。
//     - bindImageUpload(inputId, imgId, inputUrlId, callback): 绑定图片上传 // 监听change，读取Base64，更新预览，调用回调。
//     - openEditModal(id): 打开编辑弹窗 // 设置编辑ID，填充值，显示/隐藏按钮。
//     - saveContactFromModal(): 从弹窗保存联系人 // 更新或新建联系人，保存，刷新UI。
// 
// - 8. UTILS & EXPORTS (工具与启动)
//   - formatTimestamp(): 格式化时间戳 // 返回如"Dec.26 14:30"的字符串。
//   - window.exportData(): 全局导出函数 // 异步导出备份JSON文件。
//   - window.importData(input): 全局导入函数 // 读取文件，确认覆盖，导入数据，处理Quota错误。
//   - renderer: marked.Renderer对象 // 自定义Markdown渲染器，处理表格。
//   - parseCustomMarkdown(text): 解析自定义Markdown // 使用marked解析，DOMPurify净化，返回HTML。
//   - cleanMarkdownForCopy(text): 清洗Markdown为纯文本 // 去除符号，适合复制。
//   - window.onload: 启动应用 // 调用App.init()。
*/



















这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面
2.点击联系人可以进入的聊天页面

联系人页面和聊天页面右上角都有一个人设编辑，我感觉这两个的html是同一个东西，只是【联系人】页面的【人设编辑】隐藏了一些功能，就当作一个创建人设的弹窗，只有上传头像、输入姓名、输入人设功能。但【聊天页面】的人设编辑则是所有功能都展现了，包括删除该联系人、删除聊天记录、查看聊天日志等。

如下：
    <!-- ======================= -->
    <!-- 弹窗：编辑/添加角色 -->
    <!-- ======================= -->
    <div id="modal-overlay" class="hidden">
        <div class="modal glass-panel">
            <h2 id="modal-title">编辑角色</h2>
            
            <div class="input-group">
                <label>名字</label>
                <input type="text" id="edit-name" placeholder="例如：AI助手">
            </div>

            <!-- 改成支持本地上传的头像区域 -->
            <div class="input-group avatar-upload-group">
                <label>角色头像</label>
                <div class="avatar-preview-wrapper">
                    <img id="edit-avatar-preview" class="avatar-preview" src="./char.jpg" alt="预览">
                    <input type="file" id="edit-avatar-file" accept="image/*" style="display:none;">
                    <button type="button" id="edit-avatar-upload-btn" class="small-btn">上传本地图片</button>
                </div>
                <input type="text" id="edit-avatar" placeholder="或输入 Emoji / 图片URL" value="⭐">
            </div>

            <!-- 新增：用户自己的头像上传（放在角色头像下面） -->
            <div class="input-group avatar-upload-group">
                <label>我的头像（用户头像）</label>
                <div class="avatar-preview-wrapper">
                    <img id="user-avatar-preview" class="avatar-preview" src="./user.jpg" alt="预览">
                    <input type="file" id="user-avatar-file" accept="image/*" style="display:none;">
                    <button type="button" id="user-avatar-upload-btn" class="small-btn">上传本地图片</button>
                </div>
            </div>


            <div class="input-group">
                <label>人设 (System Prompt)</label>
                <textarea id="edit-prompt" rows="5" placeholder="你是一个..."></textarea>
            </div>
            
            <div class="modal-buttons">
                <button id="modal-cancel">取消</button>
                <button id="modal-save" class="primary">保存</button>
            </div>


            <!-- 【新增区域】：上下文日志按钮 -->
            <div id="log-section" class="input-group log-section">
                <label>调试信息</label>
                <button id="btn-show-log" class="small-btn log-show-btn">
                    查看teleWindy的上轮发送
                </button>
            </div>

            
            <div class="modal-danger-zone">
                <button id="modal-clear-history" class="danger-btn outline">清空聊天记录</button>
                <button id="modal-delete" class="danger-btn">【危险操作】删除此角色</button>
            </div>

        </div>
    </div>



                <!-- ====================== 2. 模型 ====================== -->
                <div class="tab-pane" id="model">

                    <h3 class="section-title">API 与模型设置</h3>
                    <div class="main-options api-section">

                        <!-- ★★★ 新增：预设管理区域 ★★★ -->
                        <!-- 这里的 ID 必须和 JS 里对应，不要改 ID，class 可以随便改 -->
                        <div id="api-preset-container" class="preset-row">
                            <select id="preset-select" class="setting-input" style="flex:1;">
                                <option value="">-- 选择 API 预设 --</option>
                            </select>
                            <div class="preset-btn-group">
                                <button id="save-preset-btn" type="button" class="icon-btn">保存</button>
                                <button id="del-preset-btn" type="button" class="icon-btn danger">删除</button>
                            </div>
                        </div>
                        <!-- ★★★ 结束 ★★★ -->

                        <!-- API 地址 -->
                        <div class="main-option api-input-card">
                            <label class="api-label">API 地址，不加v1/chat/completions</label>
                            <input type="url" id="custom-api-url" class="setting-input" 
                                placeholder="例如: https://api.openai.com/v1">
                        </div>

                        <!-- API 密钥 -->
                        <div class="main-option api-input-card">
                            <label class="api-label">API 密钥</label>
                            <input type="password" id="custom-api-key" class="setting-input" 
                                placeholder="sk-XXXXXXXXXXXXXXXXXXXXXXXX" autocomplete="off">
                        </div>

                        <!-- 模型选择 -->
                        <div class="main-option model-card">
                            <label for="custom-model-select" class="api-label2">模型</label>


                            <!-- 模型设置区域 -->
                            <div class="model-setting-group">
                                
                                <!-- 1. 输入框 (去掉了右边的小图标) -->
                                <input type="text" id="custom-model-select" list="model-options" class="model-select" placeholder="手动输入或点击拉取...">
                                <datalist id="model-options"></datalist>

                                <!-- 2. 按钮组 (模仿 Gist 的排版，左右并排) -->
                                <div class="api-buttons-row">
                                    <button type="button" id="fetch-models-btn" class="api-btn primary">
                                        拉取模型
                                    </button>
                                    <button type="button" id="test-api-btn" class="api-btn">
                                        测试 API
                                    </button>
                                </div>

                                <!-- 3. 测试结果显示 (放在按钮下面) -->
                                <div id="test-api-status" class="api-status-text status-idle">- API测试准备就绪 -</div>

                            </div>


                        </div>
                    </div>
                </div>






现在的问题：
1.我想在【聊天页面】的【人设编辑】中，加入“导入导出聊天记录”功能，就是2个并排按钮，一个是导出聊天记录，一个是导入聊天记录。就是导入导出当前所有聊天记录的json，实现聊天记录的保存和恢复。

我的css大概是这个风格：
.small-btn {
    padding: 10px 62px;
    font-size: 12px;
    background: #ffffff;
    color: rgb(82, 82, 82);
    border: 1px solid var(--btn-border-color);
    border-radius: 8px;
    cursor: pointer;
}

#modal-save {
    background: var(--primary-btn-color);
    color: var(--primary-btn-text);
    border: 0.7px solid var(--primary-btn-text);
}


以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改把，谢谢gemini



/*
// =========================================
// 中文的树状代码目录
// =========================================
// 注意：这是一个树状结构，展示代码的组织架构。每个章节对应代码中的主要部分，每个函数/对象后附带简要描述（这是干啥的）。
// 
// - 1. CONFIG & STATE (配置与状态)
//   - CONFIG: 常量配置对象，包含存储键、默认设置和系统提示等，用于全局配置。
//     - STORAGE_KEY: 'teleWindy_char_data_v1' // 联系人数据存储键
//     - SETTINGS_KEY: 'teleWindy_settings_v1' // 设置存储键
//     - WORLD_INFO_KEY: 'teleWindy_world_info_v2' // 世界信息存储键（升级到v2）
//     - CHAT_PAGE_SIZE: 15 // 每次加载的聊天条数
//     - GIST_ID_KEY: 'telewindy-gist-id' // Gist ID存储键
//     - DEFAULT: 默认配置对象，包括API_URL、MODEL等默认值
//     - SYSTEM_PROMPT: 系统提示字符串，用于指导AI行为
//   - STATE: 运行时状态对象，存储动态数据，如联系人列表、当前ID等。
//     - contacts: [] // 联系人数组
//     - worldInfoBooks: [] // 世界信息书籍数组
//     - currentContactId: null // 当前联系人ID
//     - currentBookId: null // 当前世界信息书籍ID
//     - settings: {} // 当前设置
//     - typingContactId: null // 正在输入的联系人ID
//     - visibleMsgCount: 15 // 当前显示的消息条数
// 
// - 1.5. DB UTILS (IndexedDB 简易封装)
//   - DB: IndexedDB操作对象，提供数据库交互方法。
//     - dbName: 'TeleWindyDB' // 数据库名称
//     - storeName: 'store' // 对象存储名称
//     - version: 1 // 数据库版本
//     - open(): 打开数据库，返回Promise // 异步打开IndexedDB数据库，处理升级。
//     - get(key): 获取指定键的值，返回Promise // 从数据库读取数据。
//     - set(key, value): 设置指定键的值，返回Promise // 向数据库写入数据。
//     - remove(key): 删除指定键，返回Promise // 从数据库删除数据。
//     - clear(): 清空存储，返回Promise // 清空整个对象存储。
//     - exportAll(): 导出所有数据，返回Promise // 使用游标遍历并导出所有键值对。
// 
// - 2. STORAGE SERVICE (本地持久化 - IndexedDB 版)
//   - Storage: 存储服务对象，处理数据加载和保存，包括迁移逻辑。
//     - load(): 加载所有数据，包括设置、联系人和世界信息 // 从IndexedDB或LocalStorage加载数据，进行迁移和默认处理。
//     - saveContacts(): 保存联系人数据 // 将STATE.contacts保存到IndexedDB。
//     - saveSettings(): 保存设置数据 // 将STATE.settings保存到IndexedDB。
//     - saveWorldInfo(): 保存世界信息数据 // 将STATE.worldInfoBooks保存到IndexedDB。
//     - exportAllForBackup(): 导出所有数据用于备份 // 从DB导出数据，加密Token，返回对象。
//     - importFromBackup(data): 导入备份数据 // 清空DB，解密Token，写入新数据。
// 
// - 3. WORLD INFO ENGINE (世界信息引擎，已修正)
//   - WorldInfoEngine: 世界信息处理对象，管理导入、导出和扫描。
//     - importFromST(jsonString, fileName): 从SillyTavern格式导入世界信息 // 解析JSON，创建新书籍条目，兼容旧格式。
//     - exportToST(book): 导出世界信息到SillyTavern格式 // 将书籍条目转换为JSON字符串。
//     - scan(userText, history, currentContactId, currentContactName): 扫描上下文触发世界信息 // 检查关键词或常量，返回触发的世界信息内容。
// 
// - 4. API SERVICE (LLM通信)
//   - API: API服务对象，处理模型获取和聊天请求。
//     - getProvider(url): 根据URL获取提供商类型 // 判断API是Claude、Gemini还是OpenAI。
//     - fetchModels(url, key): 获取模型列表 // 发送GET请求到/models端点，返回JSON。
//     - estimateTokens(text): 估算Token数量 // 根据字符类型粗略计算Token消耗。
//     - chat(messages, settings): 发送聊天请求 // 构建请求体，调用API，处理不同提供商，返回AI响应。
// 
// - 5. CLOUD SYNC (云同步，终极混合版 - 含安全防御)
//   - CloudSync: 云同步对象，处理Gist或自定义服务器备份。
//     - els: DOM元素对象 // 元素引用集合
//     - init(): 初始化同步界面 // 恢复保存的模式、URL等，调用toggleMode。
//     - toggleMode(): 切换同步模式 // 根据选择显示/隐藏URL或Gist ID输入。
//     - showStatus(msg, isError): 显示状态消息 // 更新状态文本和颜色。
//     - getAuth(): 获取认证Token或密码 // 从输入或设置读取Token，处理加密。
//     - _maskToken(token): 混淆Token // 反转并base64编码Token以防扫描。
//     - _unmaskToken(maskedToken): 解混淆Token // base64解码并反转Token。
//     - _preparePayload(): 准备上传负载 // 导出数据，混淆Token，添加元信息。
//     - updateBackup(): 更新备份 // 根据模式调用自定义或Gist上传。
//     - findBackup(): 查找Gist备份 // 请求Gist列表，匹配描述，更新ID。
//     - restoreBackup(): 恢复备份 // 确认后从云端拉取数据，调用_safeRestore。
//     - _safeRestore(data): 安全恢复数据 // 解混淆Token，清空旧数据，导入新数据，处理Quota错误。
//     - _uploadToCustom(): 上传到自定义服务器 // POST负载到自定义URL，使用密码认证。
//     - _fetchFromCustom(password): 从自定义服务器拉取 // GET请求，使用密码认证，返回JSON。
//     - _uploadToGist(): 上传到Gist // POST或PATCH到Gist API，创建或更新备份。
//     - _fetchFromGist(token): 从Gist拉取 // GET Gist内容，处理截断，返回JSON。
// 
// - 6. UI RENDERER (DOM 操作)
//   - UI: UI渲染对象，处理界面更新和事件。
//     - els: DOM元素对象 // 元素引用集合
//     - init(): 初始化UI // 应用外观，渲染联系人，初始化CloudSync。
//     - applyAppearance(): 应用外观设置 // 设置背景、主题。
//     - toggleTheme(newTheme): 切换主题 // 更新设置，应用外观。
//     - switchView(viewName): 切换视图 // 显示/隐藏联系人列表或聊天视图。
//     - renderContacts(): 渲染联系人列表 // 使用模板克隆填充联系人数据，包括预览和红点。
//     - renderBookSelect(): 渲染世界书选择下拉 // 填充书籍选项，更新UI。
//     - updateCurrentBookSettingsUI(): 更新当前书设置UI // 设置书籍绑定角色选择。
//     - renderWorldInfoList(): 渲染世界信息条目列表 // 填充条目，高亮当前编辑。
//     - initWorldInfoTab(): 初始化世界信息Tab // 填充角色选择，渲染书籍和列表。
//     - showEditModal(oldText, onConfirmCallback): 显示编辑弹窗 // 填充旧文本，绑定确认回调。
//     - removeLatestAiBubbles(): 移除最新AI气泡 // 删除聊天中最后一个AI消息组。
//     - renderChatHistory(contact, isLoadMore, keepScrollPosition): 渲染聊天历史 // 渲染消息，支持分页加载，控制滚动。
//     - appendMessageBubble(text, sender, aiAvatarUrl, timestampRaw, historyIndex): 添加消息气泡 // 创建并追加气泡到组，支持动画。
//     - appendSeparator(shouldAnimate): 添加分割线 // 创建并追加分割线，支持动画。
//     - scrollToBottom(): 滚动到底部 // 将聊天容器滚动到最底。
//     - setLoading(isLoading, contactId): 设置加载状态 // 更新“正在输入”状态，仅针对当前联系人。
//     - updateRerollState(contact): 更新重滚按钮状态 // 根据历史启用/禁用重滚按钮。
//     - playWaterfall(fullText, avatar, timestamp): 播放瀑布式动画 // 逐段渲染AI响应，支持分割线和动画。
//     - initStatusBar(): 初始化状态栏 // 更新时间、电量显示，绑定事件。
//     - renderPresetMenu(): 渲染API预设菜单 // 填充预设选项，绑定事件。
// 
// - 7. APP CONTROLLER (业务逻辑)
//   - App: 应用控制器对象，管理事件和逻辑。
//     - els: DOM元素引用 // 来自UI.els
//     - init(): 初始化应用 // 加载存储，初始化UI，绑定事件，渲染联系人。
//     - enterChat(id): 进入聊天 // 设置当前ID，切换视图，渲染历史，更新状态。
//     - handleSend(isReroll): 处理发送消息 // 构建消息，调用API，渲染响应，处理重滚。
//     - openSettings(): 打开设置弹窗 // 填充设置值，渲染预设，初始化世界信息Tab。
//     - switchWorldInfoBook(bookId): 切换世界书 // 更新当前ID，刷新UI。
//     - bindCurrentBookToChar(charId): 绑定书籍到角色 // 更新书籍characterId，保存。
//     - loadWorldInfoEntry(uid): 加载世界信息条目 // 填充编辑器输入框，刷新列表。
//     - saveWorldInfoEntry(): 保存世界信息条目 // 更新或新建条目，保存，刷新UI。
//     - deleteWorldInfoEntry(): 删除世界信息条目 // 移除条目，保存，清空编辑器，刷新列表。
//     - clearWorldInfoEditor(): 清空编辑器 // 重置输入框，刷新列表。
//     - createNewBook(): 创建新书 // 提示名称，添加新书，保存，刷新UI。
//     - renameCurrentBook(): 重命名当前书 // 提示新名，更新，保存，刷新选择。
//     - deleteCurrentBook(): 删除当前书 // 确认后移除书，切换到第一本，保存，刷新UI。
//     - exportCurrentBook(): 导出当前书 // 转换为JSON，下载文件。
//     - handleImportWorldInfo(file): 处理导入世界信息 // 读取文件，导入新书，保存，刷新UI。
//     - handleSavePreset(): 保存API预设 // 提示名称，添加预设，保存，刷新菜单。
//     - handleLoadPreset(index): 加载API预设 // 填充URL、Key、Model。
//     - handleDeletePreset(): 删除API预设 // 确认后移除预设，保存，刷新菜单。
//     - saveSettingsFromUI(): 从UI保存设置 // 更新设置，处理URL，保存，应用外观。
//     - handleMessageAction(action): 处理消息动作 // 根据动作编辑/删除/复制消息，保存，刷新历史。
//     - hideMessageContextMenu(): 隐藏上下文菜单 // 设置display none，重置索引。
//     - showMessageContextMenu(msgIndex, rect): 显示上下文菜单 // 设置索引，绑定事件，防误触锁定。
//     - bindEvents(): 绑定事件 // 绑定所有点击、输入、触摸事件。
//     - readFile(file): 读取文件为Base64 // 返回Promise，读取DataURL。
//     - fetchModelsForUI(): 从UI获取模型 // 调用API.fetchModels，填充选项。
//     - bindImageUpload(inputId, imgId, inputUrlId, callback): 绑定图片上传 // 监听change，读取Base64，更新预览，调用回调。
//     - openEditModal(id): 打开编辑弹窗 // 设置编辑ID，填充值，显示/隐藏按钮。
//     - saveContactFromModal(): 从弹窗保存联系人 // 更新或新建联系人，保存，刷新UI。
// 
// - 8. UTILS & EXPORTS (工具与启动)
//   - formatTimestamp(): 格式化时间戳 // 返回如"Dec.26 14:30"的字符串。
//   - window.exportData(): 全局导出函数 // 异步导出备份JSON文件。
//   - window.importData(input): 全局导入函数 // 读取文件，确认覆盖，导入数据，处理Quota错误。
//   - renderer: marked.Renderer对象 // 自定义Markdown渲染器，处理表格。
//   - parseCustomMarkdown(text): 解析自定义Markdown // 使用marked解析，DOMPurify净化，返回HTML。
//   - cleanMarkdownForCopy(text): 清洗Markdown为纯文本 // 去除符号，适合复制。
//   - window.onload: 启动应用 // 调用App.init()。
*/

















