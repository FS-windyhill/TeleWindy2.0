这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面
2.点击联系人可以进入的聊天页面

聊天页面中，我加了一个长按编辑消息的按钮，由此也更改发给ai的上下文。我的消息是一个消息组，user/char发出由两个换行分割的若干句子，UI识别两个换行符，由此将其在界面上切分成多条消息，以达到发送多条消息的视觉效果。但是我编辑消息，只打算编辑整个消息组，不打算编辑被切分后的消息。
（ps：原先一个消息组在UI上是被切分成多条消息的比如/n/n这样/n/n就是好几条。它在页面上是单独的message-wrapper，但是现在我把它们打包成message-group，这样点击其中拆分后的一条，就可以识别并编辑整组完整消息了）


现在的问题：
1.一旦【用户新发消息】之后，哪怕长按用户发的消息，点击编辑，弹出来的都是char的消息。不管长按【用户】的还是【char】的，编辑的都是【char】的消息。但是，【退出界面重新进一次】聊天窗口后，窗口UI根据历史上下文重新渲染界面，又能够正常编辑每一条消息了。

2.老师，手机界面长按编辑的时候，会跳出来ios/安卓系统自带的那个【复制、剪切、分享】啥啥的菜单，能给它禁用掉嘛？我感觉很影响体验

你帮我排查下问题好嘛，以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改把，谢谢gemini




这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面，像微信一样，有好友头像、和消息预览
2.点击联系人可以进入的聊天页面

我加了一个长按编辑消息的按钮，由此也更改发给ai的上下文。我的消息是一个消息组，user/char发出由两个换行分割的若干句子，UI识别两个换行符，由此将其在界面上切分成多条消息，以达到发送多条消息的视觉效果。但是我编辑消息，只打算编辑整个消息组，不打算编辑被切分后的消息。
（ps：原先一个消息组在UI上是被切分成多条消息的比如/n/n这样/n/n就是好几条。它在页面上是单独的message-wrapper，但是现在我把它们打包成message-group，这样点击其中拆分后的一条，就可以识别并编辑整组完整消息了）


我想修改的地方：
1.为了做到时间感知，用户每次发送消息都会被程序加上一条时间戳（让AI知道时间的变化）。时间戳是直接加在上下文里的，上下文是存在本地存储indexeddb的。类似下面的：

{role: 'assistant', content: '太好啦！\n\n我最喜欢跟朋友一起玩了！\n\n我们去草地上打滚好不好？\n\n或者，或者我们可以去那边的小溪边，用石头打水漂！'}
{role: 'user', content: '[Dec.14 16:39] 好耶！走吧'}

大概是这样。
长按编辑用户消息的时候，会弹出有个文本textarea弹窗嘛。但是，因为弹窗内容估计读取的是上下文，所以，编辑的时候，也会有个[Dec.14 16:39] 在里面。
感觉这样不够智能，会让用户看到底层逻辑。
能不能在编辑的时候通过正则，还是啥方法把这个隐藏掉呀，但是上下文里仍然保留。
这个时间不需要改成当前，就保留上下文的原样就好。

2.如果我聊天时，char消息还没发来，我就退到联系人页面去了，那 联系人页面 的 消息预览 里显示的就是我自己发的最后一条消息嘛。但是这里也会显示时间戳。我想把它隐藏掉。反正面向用户的时候，除了【调试日志】里之外，不要在任何地方让用户感到这个时间戳的存在。

3.如果在 联系人页面 时，char消息发来了，能实时预览不？就像微信那样显示当前最后一条消息（被/n/n拆分过后的）的预览，然后旁边有个小红点，显示它发了几条（不是一个message group哈，是被/n/n拆分过后的条数）


你帮我改下代码好嘛，以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改吧，谢谢gemini

/*
 * =========================================
 * 树状代码目录 (TeleWindy 项目结构)
 * =========================================
 *
 * 1. CONFIG & STATE (配置与状态)
 *    ├─ CONFIG 对象
 *    │   └─ SYSTEM_PROMPT (系统提示词)
 *    └─ STATE 对象 (运行时状态)
 *
 * 1.5. DB UTILS (IndexedDB 简易封装)
 *    ├─ open()          → 打开数据库
 *    ├─ get(key)        → 读取数据
 *    ├─ set(key, value) → 写入数据
 *    ├─ remove(key)     → 删除数据
 *    ├─ clear()         → 清空数据库
 *    └─ exportAll()     → 导出所有数据（使用游标）
 *
 * 2. STORAGE SERVICE (本地持久化 - IndexedDB 版)
 *    ├─ load()                  → 初始化加载所有数据（设置、联系人、世界书 + 数据迁移）
 *    ├─ saveContacts()          → 保存联系人
 *    ├─ saveSettings()          → 保存设置
 *    ├─ saveWorldInfo()         → 保存世界书
 *    ├─ exportAllForBackup()    → 导出备份（含 Token 加密）
 *    └─ importFromBackup(data)  → 导入备份（含 Token 解密）
 *
 * 3. WORLD INFO ENGINE (世界书引擎)
 *    ├─ importFromST(jsonString, fileName) → 从 SillyTavern 格式导入世界书
 *    ├─ exportToST(book)                   → 导出为 SillyTavern 格式
 *    └─ scan(userText, history, currentContactId, currentContactName)
 *                                          → 扫描上下文并注入触发的内容
 *
 * 4. API SERVICE (LLM 通信)
 *    ├─ getProvider(url)      → 判断 API 提供商 (claude/gemini/openai)
 *    ├─ fetchModels(url, key) → 拉取可用模型列表
 *    ├─ estimateTokens(text)  → 估算 Token 数量（中英文分开计算）
 *    └─ chat(messages, settings) → 核心聊天请求（支持多种提供商 + 日志记录）
 *
 * 5. CLOUD SYNC (云同步 - Gist / 自定义服务器混合版)
 *    ├─ init()                  → 初始化 UI 与恢复状态
 *    ├─ toggleMode()            → 切换同步模式（Gist ↔ 自定义）
 *    ├─ showStatus(msg, isError)→ 显示同步状态
 *    ├─ getAuth()               → 安全获取 Token/密码
 *    ├─ _maskToken() / _unmaskToken() → Token 混淆/解混淆（防泄露）
 *    ├─ _preparePayload()       → 准备上传数据（含混淆）
 *    ├─ updateBackup()          → 主入口：根据模式上传
 *    ├─ findBackup()            → 自动查找 GitHub Gist 备份
 *    ├─ restoreBackup()         → 恢复备份
 *    ├─ _safeRestore(data)      → 安全恢复（防空间不足）
 *    ├─ _uploadToCustom()       → 自定义服务器上传
 *    ├─ _fetchFromCustom()      → 自定义服务器下载
 *    ├─ _uploadToGist()         → GitHub Gist 上传/更新
 *    └─ _fetchFromGist()        → GitHub Gist 下载
 *
 * 6. UI RENDERER (界面渲染与 DOM 操作)
 *    ├─ init()                       → 初始化外观与联系人列表
 *    ├─ applyAppearance()            → 应用主题与壁纸
 *    ├─ toggleTheme(newTheme)        → 切换日夜模式
 *    ├─ switchView(viewName)         → 切换列表 ↔ 聊天视图
 *    ├─ renderContacts()             → 渲染联系人侧边栏
 *    ├─ renderBookSelect()           → 渲染世界书下拉框
 *    ├─ updateCurrentBookSettingsUI()→ 更新当前书绑定角色 UI
 *    ├─ renderWorldInfoList()        → 渲染世界书条目列表
 *    ├─ initWorldInfoTab()           → 初始化世界书 Tab 页面
 *    ├─ renderChatHistory(contact)   → 渲染完整聊天记录
 *    ├─ createSingleBubble(...)      → 创建单个消息气泡
 *    ├─ appendMessageBubble(...)     → 追加消息气泡（支持分段）
 *    ├─ showEditModal(...)           → 显示消息编辑弹窗
 *    ├─ removeLatestAiBubbles()      → 删除最新 AI 消息组（用于重滚）
 *    ├─ scrollToBottom()             → 滚动到底部
 *    ├─ setLoading(isLoading)        → 设置“正在输入”状态
 *    ├─ updateRerollState(contact)   → 更新重滚按钮状态
 *    ├─ playWaterfall(fullText, ...) → 瀑布流逐段显示 AI 回复
 *    └─ renderPresetMenu()           → 渲染 API 预设下拉菜单
 *
 * 7. APP CONTROLLER (核心业务逻辑)
 *    ├─ init()                          → 应用启动入口（加载数据 → 初始化 UI → 绑定事件）
 *    ├─ enterChat(id)                   → 进入指定聊天
 *    ├─ handleSend(isReroll)            → 发送消息 / 重滚
 *    ├─ openSettings()                  → 打开主设置弹窗
 *    ├─ switchWorldInfoBook(bookId)     → 切换当前世界书
 *    ├─ bindCurrentBookToChar(charId)   → 绑定当前书到角色
 *    ├─ loadWorldInfoEntry(uid)         → 加载条目到编辑器
 *    ├─ saveWorldInfoEntry()            → 保存条目（含名称逻辑）
 *    ├─ deleteWorldInfoEntry()          → 删除条目
 *    ├─ clearWorldInfoEditor()          → 清空编辑器
 *    ├─ createNewBook()                 → 新建世界书
 *    ├─ renameCurrentBook()             → 重命名当前书
 *    ├─ deleteCurrentBook()             → 删除当前书
 *    ├─ exportCurrentBook()             → 导出当前书为 ST 格式
 *    ├─ handleImportWorldInfo(file)     → 导入 ST 世界书
 *    ├─ handleSavePreset()              → 保存 API 预设
 *    ├─ handleLoadPreset(index)         → 加载 API 预设
 *    ├─ handleDeletePreset()            → 删除 API 预设
 *    ├─ saveSettingsFromUI()            → 从设置界面保存
 *    ├─ handleMessageAction(action)     → 处理消息右键操作（编辑/删除/复制）
 *    ├─ showMessageContextMenu(...)     → 显示消息上下文菜单（含防误触）
 *    ├─ hideMessageContextMenu()        → 隐藏上下文菜单
 *    ├─ bindEvents()                    → 集中绑定所有 DOM 事件
 *    ├─ readFile(file)                  → 读取文件为 base64
 *    ├─ fetchModelsForUI()              → UI 中拉取模型列表
 *    ├─ bindImageUpload(...)            → 绑定图片上传逻辑
 *    ├─ openEditModal(id)               → 打开角色编辑弹窗
 *    └─ saveContactFromModal()          → 保存角色修改
 *
 * 8. UTILS & EXPORTS (工具函数与全局导出)
 *    ├─ formatTimestamp()               → 格式化时间戳
 *    ├─ window.exportData()             → 全局导出备份函数
 *    └─ window.importData(input)        → 全局导入备份函数
 *
 * 启动：window.onload = () => App.init();
 */







这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面
2.点击联系人可以进入的聊天页面

聊天页面中，每次加载全量历史记录比较卡顿，我可以每次加载15条吗，剩下的，拉到最上面，会有个“加载更多消息”按钮，点一次，加载15条。等到最后一次点的时候，可能不到15条，那就全部加载出来即可。

你帮我改下代码好嘛，以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改吧，谢谢gemini

html css js分开写可以吗，谢谢

/**
 * ================================================
 * TeleWindy 代码结构树状目录（2025-12-15）
 * ================================================
 *
 * 1. CONFIG & STATE (配置与状态)
 *    ├─ CONFIG 对象
 *    │   └─ SYSTEM_PROMPT
 *    └─ STATE 对象
 *
 * 1.5. DB UTILS (IndexedDB 简易封装)
 *    ├─ open()
 *    ├─ get(key)
 *    ├─ set(key, value)
 *    ├─ remove(key)
 *    ├─ clear()
 *    └─ exportAll()
 *
 * 2. STORAGE SERVICE (本地持久化 - IndexedDB 版)
 *    ├─ load()
 *    ├─ saveContacts()
 *    ├─ saveSettings()
 *    ├─ saveWorldInfo()
 *    ├─ exportAllForBackup()
 *    └─ importFromBackup(data)
 *
 * 3. WORLD INFO ENGINE (世界书引擎)
 *    ├─ importFromST(jsonString, fileName)
 *    ├─ exportToST(book)
 *    └─ scan(userText, history, currentContactId, currentContactName)
 *
 * 4. API SERVICE (LLM通信)
 *    ├─ getProvider(url)
 *    ├─ fetchModels(url, key)
 *    ├─ estimateTokens(text)
 *    └─ chat(messages, settings)
 *
 * 5. CLOUD SYNC (云同步 - Gist & 自定义服务器)
 *    ├─ init()
 *    ├─ toggleMode()
 *    ├─ showStatus(msg, isError)
 *    ├─ getAuth()
 *    ├─ _maskToken(token)
 *    ├─ _unmaskToken(maskedToken)
 *    ├─ _preparePayload()
 *    ├─ updateBackup()
 *    ├─ findBackup()
 *    ├─ restoreBackup()
 *    ├─ _safeRestore(data)
 *    ├─ _uploadToCustom()
 *    ├─ _fetchFromCustom(password)
 *    ├─ _uploadToGist()
 *    └─ _fetchFromGist(token)
 *
 * 6. UI RENDERER (DOM 操作与渲染)
 *    ├─ init()
 *    ├─ applyAppearance()
 *    ├─ toggleTheme(newTheme)
 *    ├─ switchView(viewName)
 *    ├─ renderContacts()
 *    ├─ renderBookSelect()
 *    ├─ updateCurrentBookSettingsUI()
 *    ├─ renderWorldInfoList()
 *    ├─ initWorldInfoTab()
 *    ├─ createSingleBubble(...)
 *    ├─ showEditModal(oldText, onConfirmCallback)
 *    ├─ removeLatestAiBubbles()
 *    ├─ renderChatHistory(contact)
 *    ├─ appendMessageBubble(...)
 *    ├─ scrollToBottom()
 *    ├─ setLoading(isLoading)
 *    ├─ updateRerollState(contact)
 *    ├─ playWaterfall(fullText, avatar, timestamp)
 *    └─ renderPresetMenu()
 *
 * 7. APP CONTROLLER (业务逻辑主控)
 *    ├─ init()
 *    ├─ enterChat(id)
 *    ├─ handleSend(isReroll)
 *    ├─ openSettings()
 *    ├─ switchWorldInfoBook(bookId)
 *    ├─ bindCurrentBookToChar(charId)
 *    ├─ loadWorldInfoEntry(uid)
 *    ├─ saveWorldInfoEntry()
 *    ├─ deleteWorldInfoEntry()
 *    ├─ clearWorldInfoEditor()
 *    ├─ createNewBook()
 *    ├─ renameCurrentBook()
 *    ├─ deleteCurrentBook()
 *    ├─ exportCurrentBook()
 *    ├─ handleImportWorldInfo(file)
 *    ├─ handleSavePreset()
 *    ├─ handleLoadPreset(index)
 *    ├─ handleDeletePreset()
 *    ├─ saveSettingsFromUI()
 *    ├─ handleMessageAction(action)
 *    ├─ hideMessageContextMenu()
 *    ├─ showMessageContextMenu(msgIndex, rect)
 *    ├─ bindEvents()
 *    ├─ readFile(file)
 *    ├─ fetchModelsForUI()
 *    ├─ bindImageUpload(...)
 *    ├─ openEditModal(id)
 *    └─ saveContactFromModal()
 *
 * 8. UTILS & EXPORTS (工具函数与全局导出)
 *    ├─ formatTimestamp()
 *    ├─ window.exportData()
 *    └─ window.importData(input)
 *
 * 启动入口：window.onload = () => App.init();
 * ================================================
 */




2.目前聊天界面好像是所有人公用的，比如我给喜羊羊发了消息，它还没回复完（并且窗口上方还在显示“用户正在输入”），我就点进懒洋洋的窗口，那么懒羊羊的窗口上方也会显示“用户正在输入”，而且喜羊羊新发的消息会追加到懒羊羊的窗口下，需要退出懒洋洋窗口重新进一遍，令UI重新渲染和懒羊羊的历史记录，界面才会变正常


长按复制的时候，因为复制估计读取的是上下文，所以，复制的时候，也会有个[Dec.14 16:39] 在里面。能不能当用户复制消息的时候，用正则把时间戳切掉呀？不过AI的消息没有时间戳，最好有/无时间戳都能兼容的那种。
我在【编辑】的相关代码里已经用正则去过时间戳了，但是【复制】相关代码还妹有。
// 3. 执行动作
if (action === 'edit') {
// ★ 修改点：智能分离时间戳
// 定义时间戳正则，跟你在 renderChatHistory 里用的一样
const timestampRegex = /^[[A-Z][a-z]{2}.\d{1,2}\s\d{2}:\d{2}]\s/;
2.第二个问题：我的istyping【对方正在输入...】有时候会在对方发消息过来之后还在显示，需要退出聊天界面，点开另一个人的窗口，让窗口重新渲染一下，变成【在线】，再回到那个窗口，才会正常显示【在线】。但这不是次次都发生，只是偶尔会发生
你帮我改下代码好嘛，以下是我的代码目录，你告诉我要检查哪几个函数，我发来给你帮我改改吧，谢谢gem










这是我的前端网页，就是接入API和AI角色扮演的，类似sillytavern，只是比较简单。


目前我前端有两个页面，分别是
1.一进去就是联系人页面
2.点击联系人可以进入的聊天页面

聊天页面中，消息逻辑是这样的：user/char发出由两个换行分割的若干句子，UI识别两个换行符，由此将其在界面上切分成多条消息，以达到发送多条消息的视觉效果。实际的上下文中，这些并不是多条消息，而只是带/N/N的单条消息。而UI中，我将其设为bubble->wrapper->message group的三级消息结构，一个group就是整个带/N/N的消息组，也就是一次发送的、在界面上被拆分为多条的所有消息。

我目前的UI加载逻辑是读取历史记录中的消息，并且用正则清洗掉其中的时间戳（但是保留实际历史上下文中的时间戳，只是在渲染的时候加以裁切，形成一种没有时间戳的视觉效果），以及简易的markdown格式美化（那些*和###）：在js中，将加*/#的文字设置为专门的一类，用CSS加以美化，比如实现加粗。

我目前的markdown识别还是很原始的，只是通过正则来识别，然后手动的把它作为CSS类进行加粗。但是我现在发现一个问题就是它没有办法显示表格。（不过呢气泡作为消息载体，气泡的宽度也是有限的好像，能让表格自适应bubble宽度吗）
不过现在先不想宽度那么多吧，先思考一下怎么才能让我的聊天记录窗口里面显示markdown格式的表格呢。

我之前的简易markdown长这样：

/**
 * 1. 简易 Markdown 解析器 (用于气泡渲染)
 * 注意：必须先进行 HTML 转义防止 XSS，然后再替换 Markdown 语法
 */
function parseCustomMarkdown(text) {
    if (!text) return '';

    // 1. XSS 防御：先把原有的 < > & 替换掉，防止用户输入恶意代码
    let html = text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");

    // 2. 处理引用 > (你的需求：直接删除 > 并视为双换行，以便后续切分)
    // 注意：这一步最好在切分气泡前做，但如果在气泡内渲染，我们可以把它变为空行或分割线
    // 如果你的切分逻辑是在渲染前做的，这里只处理残留的 visual 效果
    html = html.replace(/^>\s*/gm, '\n\n'); 

    // 3. 处理标题 ### (你的需求：加粗，字号不变)
    // 匹配 1-6 个 # 开头的行，将其内容包裹在 <b> 标签中
    html = html.replace(/^#+\s+(.*)$/gm, '<b>$1</b>');

    // 4. 处理加粗 ***bold*** 或 **bold**
    html = html.replace(/\*\*\*(.*?)\*\*\*/g, '<b>$1</b>');
    html = html.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');

    // 5. 处理斜体 *italic*
    html = html.replace(/\*(.*?)\*/g, '<i>$1</i>');

    // 6. 处理圆点列表 * list (你的需求：- 不管，只处理 *)
    // 将行首的 "* " 替换为 "• " (实心圆点字符) 或者 HTML <ul> 结构
    // 为了保持气泡简单，直接用字符替换最稳妥
    html = html.replace(/^\*\s+/gm, '• ');

    // 7. 处理换行 (保留显示换行)
    html = html.replace(/\n/g, '<br>');

    return html;
}

/**
 * 2. 纯文本清洗器 (用于复制)
 * 你的需求：保留换行，去除所有 Markdown 符号 (*, #, >)
 */
function cleanMarkdownForCopy(text) {
    if (!text) return '';
    let clean = text;
    clean = clean.replace(/^>\s*/gm, '');  // 去引用
    clean = clean.replace(/^#+\s+/gm, ''); // 去标题
    
    // 👇 优化这一块：先去列表头的 "* "，再去剩下的 "*"
    clean = clean.replace(/^\*\s+/gm, ''); // 先删列表头的 * 和空格
    clean = clean.replace(/\*/g, '');      // 再删加粗/斜体的 *
    
    return clean;
}

我的代码目录：
中文树状代码目录：
- 1. CONFIG & STATE (配置与状态)
  - CONFIG: 定义配置常量，包括存储键、默认值和系统提示。
  - STATE: 定义运行时状态，包括联系人、世界信息书籍、当前联系人ID等。
- 1.5. DB UTILS (IndexedDB 简易封装)
  - DB.open(): 打开IndexedDB数据库，返回Promise。
  - DB.get(key): 从数据库获取指定键的值，返回Promise。
  - DB.set(key, value): 将值存入数据库的指定键，返回Promise。
  - DB.remove(key): 删除数据库中的指定键，返回Promise。
  - DB.clear(): 清空整个对象存储，返回Promise。
  - DB.exportAll(): 使用游标导出数据库所有数据，返回Promise。
- 2. STORAGE SERVICE (本地持久化 - IndexedDB 版)
  - Storage.load(): 加载设置、联系人和世界信息，支持从LocalStorage迁移数据。
  - Storage.saveContacts(): 保存联系人数据到IndexedDB。
  - Storage.saveSettings(): 保存设置数据到IndexedDB。
  - Storage.saveWorldInfo(): 保存世界信息书籍到IndexedDB。
  - Storage.exportAllForBackup(): 导出所有数据用于备份，加密Token。
  - Storage.importFromBackup(data): 从备份数据导入，解密Token并写入数据库。
- 3. WORLD INFO ENGINE (已修正)
  - WorldInfoEngine.importFromST(jsonString, fileName): 从SillyTavern格式导入世界信息条目，创建新书。
  - WorldInfoEngine.exportToST(book): 将世界书导出为SillyTavern格式的JSON。
  - WorldInfoEngine.scan(userText, history, currentContactId, currentContactName): 扫描上下文触发世界信息条目，返回触发的知识内容。
- 4. API SERVICE (LLM通信)
  - API.getProvider(url): 根据URL判断API提供者（如claude、gemini或openai）。
  - API.fetchModels(url, key): 从API获取模型列表。
  - API.estimateTokens(text): 估算文本的Token数量，区分CJK和其它字符。
  - API.chat(messages, settings): 发送聊天消息到API，支持不同提供者，记录日志并返回响应。
- 5. CLOUD SYNC (终极混合版 - 含安全防御)
  - CloudSync.init(): 初始化云同步UI，从本地存储恢复设置。
  - CloudSync.toggleMode(): 根据选择切换自定义URL或Gist模式，更新UI。
  - CloudSync.showStatus(msg, isError): 在UI显示状态消息，带颜色区分。
  - CloudSync.getAuth(): 获取认证Token或密码，支持加密兼容。
  - CloudSync._maskToken(token): 混淆Token以防扫描。
  - CloudSync._unmaskToken(maskedToken): 解混淆Token。
  - CloudSync._preparePayload(): 准备上传备份数据，混淆Token。
  - CloudSync.updateBackup(): 根据模式上传备份到自定义服务器或Gist。
  - CloudSync.findBackup(): 在GitHub搜索TeleWindy备份Gist并填充ID。
  - CloudSync.restoreBackup(): 从云端恢复备份，确认覆盖。
  - CloudSync._safeRestore(data): 安全恢复数据，解混淆Token并处理空间问题。
  - CloudSync._uploadToCustom(): 上传备份到自定义服务器。
  - CloudSync._fetchFromCustom(password): 从自定义服务器获取备份。
  - CloudSync._uploadToGist(): 上传备份到GitHub Gist，支持创建或更新。
  - CloudSync._fetchFromGist(token): 从GitHub Gist获取备份，支持截断处理。
- 6. UI RENDERER (DOM 操作)
  - UI.init(): 初始化UI，应用外观并渲染联系人。
  - UI.applyAppearance(): 应用壁纸和主题到body。
  - UI.toggleTheme(newTheme): 切换主题并保存。
  - UI.switchView(viewName): 切换联系人列表或聊天视图。
  - UI.renderContacts(): 渲染联系人列表，包括头像、预览和红点。
  - UI.renderBookSelect(): 渲染世界书选择下拉框。
  - UI.updateCurrentBookSettingsUI(): 更新当前书的角色绑定UI。
  - UI.renderWorldInfoList(): 渲染世界信息条目列表，带高亮。
  - UI.initWorldInfoTab(): 初始化世界信息Tab，包括角色选择和渲染。
  - UI.showEditModal(oldText, onConfirmCallback): 显示消息编辑模态框。
  - UI.removeLatestAiBubbles(): 移除聊天中最新AI消息组。
  - UI.renderChatHistory(contact, isLoadMore): 渲染聊天历史，支持加载更多。
  - UI.createSingleBubble(text, sender, aiAvatarUrl, timestampRaw, historyIndex, shouldAnimate): 创建单个消息气泡，支持Markdown和动画。
  - UI.appendMessageBubble(text, sender, aiAvatarUrl, timestampRaw, historyIndex): 追加消息气泡到组。
  - UI.scrollToBottom(): 滚动聊天到底部。
  - UI.setLoading(isLoading, contactId): 设置加载状态，显示“正在输入”或“在线”。
  - UI.updateRerollState(contact): 更新reroll按钮状态。
  - UI.playWaterfall(fullText, avatar, timestamp): 逐段追加AI消息，模拟瀑布动画。
  - UI.initStatusBar(): 初始化顶栏状态栏，包括时间和电量。
  - UI.renderPresetMenu(): 渲染API预设菜单，包括保存、加载和删除。
- 7. APP CONTROLLER (业务逻辑)
  - App.init(): 初始化应用，加载存储并绑定事件。
  - App.enterChat(id): 进入指定联系人聊天，渲染历史并更新状态。
  - App.handleSend(isReroll): 处理消息发送或reroll，包括API调用和UI更新。
  - App.openSettings(): 打开设置模态，填充值并初始化Tab。
  - App.switchWorldInfoBook(bookId): 切换当前世界书并刷新UI。
  - App.bindCurrentBookToChar(charId): 绑定当前书到角色并保存。
  - App.loadWorldInfoEntry(uid): 加载世界信息条目到编辑器。
  - App.saveWorldInfoEntry(): 保存或新建世界信息条目。
  - App.deleteWorldInfoEntry(): 删除世界信息条目。
  - App.clearWorldInfoEditor(): 清空世界信息编辑器。
  - App.createNewBook(): 创建新世界书。
  - App.renameCurrentBook(): 重命名当前世界书。
  - App.deleteCurrentBook(): 删除当前世界书。
  - App.exportCurrentBook(): 导出当前世界书为JSON。
  - App.handleImportWorldInfo(file): 处理世界信息导入文件。
  - App.handleSavePreset(): 保存API预设。
  - App.handleLoadPreset(index): 加载API预设到UI。
  - App.handleDeletePreset(): 删除API预设。
  - App.saveSettingsFromUI(): 从设置UI保存配置。
  - App.handleMessageAction(action): 处理消息动作如编辑、删除、复制。
  - App.hideMessageContextMenu(): 隐藏消息上下文菜单。
  - App.showMessageContextMenu(msgIndex, rect): 显示消息上下文菜单，防误触。
  - App.bindEvents(): 绑定所有事件监听器。
  - App.readFile(file): 读取文件为Base64。
  - App.fetchModelsForUI(): 从API获取模型并更新UI。
  - App.bindImageUpload(inputId, imgId, inputUrlId, callback): 绑定图片上传事件。
  - App.openEditModal(id): 打开角色编辑模态，填充值。
  - App.saveContactFromModal(): 从模态保存角色数据。
- 8. UTILS & EXPORTS (工具与启动)
  - formatTimestamp(): 生成格式化的时间戳字符串。
  - window.exportData(): 导出所有数据为JSON文件。
  - window.importData(input): 从文件导入备份数据，支持空间检查。
  - parseCustomMarkdown(text): 解析自定义Markdown为HTML，支持加粗、斜体等。
  - cleanMarkdownForCopy(text): 清洗Markdown为纯文本，用于复制。
  - window.onload: 启动应用初始化。











老师，这是一个类似sillytavern的AI聊天前端，我写的。我为了让AI感知世间，在user发的每一条消息前面都加了一条时间戳。类似：

你好啊！吃了吗？→处理后：[Dec.29 20:07]你好啊！吃了吗？

之前他都可以正常工作，后来项目改来改去，今天突然发现这个功能不见了？我发送的消息没有被加上时间戳了？

我渲染聊天界面、复制消息、编辑消息、contact联系人界面预览消息的时候，为了美观，都是用正则把时间戳（在视觉上）切掉的。唯一不同的是，编辑消息的时候，我只会在编辑框里把时间戳去掉（为了让时间戳不让用户看见，不然很不优雅），编辑提交之后还会重新拼回去。但是现在说这些也没用了，因为时间戳甚至都没有被加进上下文里。是啥地方出问题了吗？逻辑太复杂了我都搞不懂是哪里出错了。除了我前面粘贴给你的具体代码，下面是我的目录，有哪些代码是可能的嫌疑段落吗？



